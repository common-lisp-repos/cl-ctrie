;;;;; -*- mode: common-lisp;   common-lisp-style: modern;    coding: utf-8; -*-
;;;;;

(in-package :cl-ctrie)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Extended Descriptor Handlers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cldoc:define-descriptor-handler DEFUN (form)
  "definition of a function that may possibly be named by keyword"
  (make-instance 'cldoc::defun-descriptor
    :type (format nil "~s" (first form))
    :name (if (keywordp (second form))
            (format nil "keyword::~a" (second form))
            (format nil "~s" (second form)))
    :lambda-list (third form)
    :doc (cldoc::extract-doc (cdddr form))))


(cldoc:define-descriptor-handler DEFUN/INLINE (form)
  "inline function definition"
  (make-instance 'cldoc::defun-descriptor
    :type (format nil "~s" (first form))
    :name (format nil "~s" (second form))
    :lambda-list (third form)
    :doc (cldoc::extract-doc (cdddr form))))


(cldoc:define-descriptor-handler DEFMACRO/ONCE (form)
  "macro with support for &ONCE 'once-only' argument extension to
  the standard destructuring macro lambda list keywords"
  (make-instance 'cldoc::defmacro-descriptor
    :type (format nil "~s" (first form))
    :name (format nil "~s" (second form))
    :lambda-list (third form)
    :doc (cldoc::extract-doc (cdddr form))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Descriptor Processing 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun collect-docs  (&optional (scope :external) (sort #'string<))
  "Regenerate on-disk html documentation and collect the cached
  in-memory descriptors for further processing. If SCOPE is specified
  it must be either :EXTERNAL. corresponding to those symbols exported
  as the public API, or :HOME, which designates all symbols defined
  locally in package.  Output order may be customized by an optionally
  specified SORT function."
  (let1 dir (namestring (asdf:system-relative-pathname
                          (asdf:find-system :cl-ctrie)
                          "doc/api/"))
    (cldoc:extract-documentation 'cldoc:html dir (asdf:find-system :cl-ctrie)))
  (remove-if #'null
    (sort
      (ecase scope
        (:external (loop for item in
                     (let (syms)
                       (do-external-symbols (s (find-package :ctrie))
                         (push s syms))
                       (mapcar #'string-downcase (mapcar #'symbol-name syms)))
                     collect (cons item (mapcar #'cldoc::meta-descriptor-desc
                                          (gethash item cldoc::*name->meta-decriptors*)))))
        (:home (loop for item in
                 (let (syms)
                   (do-symbols (s #1=(find-package :ctrie))
                     (when (eq (symbol-package s) #1#)
                       (push s syms)))
                   (mapcar #'string-downcase (mapcar #'symbol-name syms)))
                 collect (cons item (mapcar #'cldoc::meta-descriptor-desc
                                      (gethash item cldoc::*name->meta-decriptors*))))))
      sort :key #'car)
    :key #'cdr))

(defun all-descs (docs)
  "Collect all 'descriptors' from an alist of the form
  '((symbol . descriptor-list) ... ) such as one generated by
  {defun:collect-docs}"
  (loop for c in docs appending (cdr c)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Lightweight Text-markup Rendering
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defgeneric render (desc &optional stream)
  (:documentation "Output to STREAM a compact rendering of a
   documentation-descriptor suitable for inclusion in lightweight
   text-markup."))


(defmethod render (desc &optional stream)
  (declare (ignore desc values))
  (values))

(defmethod render ((desc cldoc::define-condition-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::inheritence cldoc::doc cldoc::slots) desc
    (let ((slot-names (mapcar (lambda (sd) (slot-value sd 'cldoc::name)) cldoc::slots)))
      (declare (ignorable slot-names))
      (format stream "_[condition]_ `~20A (~{~S~^ ~^-~^>~})`~%~%>  ~A~%~%"
        (string-upcase cldoc::name) cldoc::inheritence cldoc::doc))))

(defmethod render ((desc cldoc::defun-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::lambda-list cldoc::doc) desc
    (format stream "_[function]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::lambda-list cldoc::doc)))

(defmethod render ((desc cldoc::defgeneric-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::lambda-list cldoc::doc cldoc::qualifiers) desc
    (declare (ignorable cldoc::qualifiers))
    (format stream "_[generic-function]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name)  cldoc::lambda-list cldoc::doc)))

(defmethod render ((desc cldoc::defmethod-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::lambda-list cldoc::doc cldoc::qualifiers) desc
    (declare (ignorable cldoc::qualifiers))
    (format stream "_[method]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::lambda-list cldoc::doc)))

(defmethod render ((desc cldoc::defmacro-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::lambda-list cldoc::doc) desc
    (format stream "_[macro]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::lambda-list cldoc::doc)))

(defmethod render ((desc cldoc::defvar-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::value cldoc::doc) desc
    (format stream "_[special-variable]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::value cldoc::doc)))

(defmethod render ((desc cldoc::defparameter-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::value cldoc::doc) desc
    (format stream "_[special-variable]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::value cldoc::doc)))

(defmethod render ((desc cldoc::defconstant-descriptor) &optional (stream nil))
  (with-slots (cldoc::name cldoc::value cldoc::doc) desc
    (format stream "_[constant-variable]_ `~20A  ~S`~%~%>  ~A~%~%"
      (string-upcase cldoc::name) cldoc::value cldoc::doc)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Top-Level Documentation Generation Interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apidoc (&optional (scope :external))
  "Collect a list of strings representing the documentation for
  CL-CTRIE rendered in a compact format suitable for inclusion in a
  lightweight text-markup format document.  If SCOPE is specified it
  must be either :EXTERNAL. corresponding to those symbols exported as
  the public API, or :HOME, which designates all symbols defined
  locally in package."
  (mapcar #'render (all-descs (collect-docs scope))))

(defun princ-apidoc (&optional (scope :external))
  "Print to *standard-output* the documentation for CL-CTRIE rendered
  in a compact format.  This is intended primarily as a convenience to
  the interactive user seeking quick reference at the REPL.  If SCOPE
  is specified it must be either :EXTERNAL. corresponding to those
  symbols exported as the public API, or :HOME, which designates all
  symbols defined locally in package."
  (mapc #'princ (apidoc scope))
  (values))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Vivisection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+donuts
(defgeneric make-diagram (thing context &key &allow-other-keys)
  (:documentation "Define a specific digram generation procedure specialized
 on the class of THING and optionally for a specific context, represented
 by an abitrary symbol naming that context."))

#+donuts
(defmethod make-diagram (thing context &key)
  "By default, attempt to generate a NODE representing THING."
  (donuts::<> thing))

#+donuts
(defun diagram (thing &optional (context *context*))
  "Generate a DONUTS diagram for THING, optionally specialized for
  a specific CONTEXT. See {defgeneric cl-ctrie::make-diagram}."
  (donuts::& ()
    (make-diagram thing context)))

#+donuts
(defmacro define-diagram (type (&optional context) &body body)
  "define a diagrammatic representation of TYPE, optionally specialized
  for a specific CONTEXT. See {defgeneric cl-ctrie::make-diagram}."
  (let ((specializer (if context `(list 'eql ,context) 't)))
    (with-gensyms (spc)
      `(let ((,spc ,specializer))
         (declare (ignorable ,spc))
         (defmethod make-diagram ((,type ,type) (context ,specializer) &key)
           ,@body)))))

#+donuts
(define-diagram snode ()
  (donuts:[] (format nil "~A | ~A" (snode-key snode) (snode-value snode))))

#+donuts
(define-diagram symbol ()
  (cl:prin1-to-string symbol))

#+donuts
(define-diagram inode ()
  (donuts:<> (concatenate 'string "inode " (string (inode-gen inode)) "\\n"
               (local-time:format-rfc1123-timestring nil (ref-stamp (inode-ref inode))))))

#+donuts
(define-diagram cnode ()
  (donuts:[]   "cnode"))

#+donuts
(define-diagram tnode ()
  (donuts:[&] (donuts:<> "tnode")))


;; (defmethod make-diagram ((thing snode) context &key)
;;   (donuts:[] (format nil "~A | ~A" (snode-key thing) (snode-value thing))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Alternate (unused) integration for use with Edi Weitz's documentation-template
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+()
(defun collect-docs (&optional (scope :external))
  (sort (ecase scope
    (:external (loop for sym being the external-symbols of (find-package :cl-ctrie)
                 nconc (documentation-template::doc-entries sym)))
    (:home     (loop for sym being the symbols  of (find-package :cl-ctrie)
                 when (eq (symbol-package sym) (find-package :cl-ctrie))
                 nconc (documentation-template::doc-entries sym))))
    #'documentation-template::doc-entry<))

#+()
(defmethod render ((type (eql :class)) entry &optional (stream nil))
  (let* ((object (first entry))
          (class (string (funcall #'type-of (find-class object nil))))
          (cpl (mapcar #'class-name (sb-mop:class-precedence-list
                                      (find-class object nil)))))
    (format stream "~%[~A] ~A~%" class object)
    (print cpl)))


