{"name":"cl-ctrie","tagline":"lock-free, concurrent, key/value index with efficient memory-mapped persistence and fast transient storage models","body":"CL-CTRIE\r\n========\r\n\r\n**CL-CTRIE** is a common-lisp implementation of the CTrie unordered map\r\ndata-structure described in the paper '*Concurrent Tries with\r\nEfficient Non-Blocking Snapshots*, (c) ACM 2-25-2012' by Prokopec,\r\nBronson, Bagwell, and Odersky.\r\n\r\n### Overview ###\r\n\r\nA brief overview of general ctrie\r\nconcepts and existing implementations is available through its \r\n[page on wikipedia](http://en.wikipedia.org/wiki/Ctrie), of which the\r\nfollowing is a brief excerpt:\r\n\r\n> The Ctrie data structure is a non-blocking\r\n> concurrent hash array mapped trie based on\r\n> single-word compare-and-swap instructions in a\r\n> shared-memory system. It supports concurrent\r\n> LOOKUP, INSERT and REMOVE operations. Just like\r\n> the hash array mapped trie, it uses the entire\r\n> 32-bit space for hash values thus having low\r\n> risk of hashcode collisions... Ctries have been\r\n> shown to be comparable in performance with\r\n> concurrent skip lists, concurrent hash tables\r\n> and similar data structures in terms of the\r\n> lookup operation...  However, they are far more\r\n> scalable than most concurrent hash tables where\r\n> the insertions are concerned. Most concurrent\r\n> hash tables are bad at conserving memory - when\r\n> the keys are removed from the hash table, the\r\n> underlying array is not [reduced in size]. Ctries\r\n> have the property that the allocated memory is\r\n> always a function of only the current number of\r\n> keys in the data-structure.  Ctries have logarithmic\r\n> complexity bounds of the basic operations...\r\n> with a low constant factor due to [large dispersal\r\n> ratio, (32^n arcs at level n)]. Ctries support a\r\n> lock-free, linearizable, constant-time SNAPSHOT\r\n> operation... This is a breakthrough in concurrent\r\n> data-structure design, since other existing concurrent\r\n> data-structures do not support snapshots. [This provides\r\n> the means to support features such as] lock-free,\r\n> linearizable iterator, size and clear operations. [This\r\n> is superior to other] existing concurrent data-structures\r\n> [which require the use of global locks [for exclusive,\r\n> blocking semantics for update access] permitting...\r\n> [no concurrent readers or writers] during any [update,\r\n> insert, remove or other modifications]. In particular,\r\n> Ctries have an O(1) ITERATOR creation operation, O(1)\r\n> CLEAR operation, O(1) DUPLICATE operation and an\r\n> amortized O(log n) operation for SIZE-RETRIEVAL.\r\n\r\n### Platform ###\r\n\r\nCurrently the lisp platform supported by cl-ctrie is SBCL version\r\n1.0.55 or greater hosted on x86/x86-64 architecture. Support could\r\neasily be entended to include other common-lisp implementations that\r\noffer atomic compare-and-swap functionality, notably LispWorks\r\n5.x/6.x, which is also well instrumented with lock-free, atomic\r\nprimitives, although this is not necessarily a high priority for the\r\ninitial development cycle.\r\n\r\n### Status\r\n\r\nAll tests should succeed; parallelism has been tested for 1,\r\n2, 4, and 8 threads on an 8-core system (Dual Intel(R) Xeon(R) CPU\r\nE5462 @ 2.80GHz), SBCL version 1.0.57.56-2273f3a, and Mac OS X Server\r\nversion 10.6.8.\r\n\r\n```\r\nStarting test run on Wednesday, September 5, 2012 09:07:32 AM EDT\r\n-----------------------------------------------------------------\r\n\r\nCHECK-ALET-FSM: 7 assertions passed, 0 failed.\r\nCHECK-ATOMIC-CLEAR: 6 assertions passed, 0 failed.\r\nCHECK-ATOMIC-UPDATE: 1 assertions passed, 0 failed.\r\nCHECK-BULK-INSERT/DROP: 1048579 assertions passed, 0 failed.\r\nCHECK-BULK-INSERT/LOOKUP: 1048578 assertions passed, 0 failed.\r\nCHECK-BYTE-VECTOR-HEX-STRING-ROUNDRIP: 10 assertions passed, 0 failed.\r\nCHECK-CATCH-CASE: 128 assertions passed, 0 failed.\r\nCHECK-CTRIE-SMOKE-TEST: 31 assertions passed, 0 failed.\r\nCHECK-DEPTH-AND-SIMPLE-EXTENSION: 8 assertions passed, 0 failed.\r\nCHECK-EXTENSION/RETRACTION/LNODE-CHAINING: 14 assertions passed, 0 failed.\r\nCHECK-FBIND: 3 assertions passed, 0 failed.\r\nCHECK-FLAG-ARC-POSITION: 165 assertions passed, 0 failed.\r\nCHECK-FLAG-COMPUTATION: 12 assertions passed, 0 failed.\r\nCHECK-LNODE-INSERTED/REMOVED: 174 assertions passed, 0 failed.\r\nCHECK-LNODE-LENGTH/ENLIST: 8 assertions passed, 0 failed.\r\nCHECK-LNODE-SEARCH: 4 assertions passed, 0 failed.\r\nCHECK-PARALLEL-INSERT-PARALLEL-DROP: 4194316 assertions passed, 0 failed.\r\nCHECK-PARALLEL-INSERT-PARALLEL-LOOKUP: 4194312 assertions passed, 0 failed.\r\nCHECK-SIMPLE-INSERT/LOOKUP: 170 assertions passed, 0 failed.\r\nCHECK-SIMPLE-INSERT/LOOKUP/DROP: 255 assertions passed, 0 failed.\r\nCHECK-TABLE-ABSTRACTION-FIXTURES: 18 assertions passed, 0 failed.\r\nCHECK-TIMING-COLLECTION-FIXTURES: 18 assertions passed, 0 failed.\r\n\r\nTOTAL: 10,486,817 assertions passed, 0 failed, 0 execution errors.\r\n```\r\n\r\n### Ideosyncrasies\r\n\r\nPerhaps most ideosyncrasies of this common-lisp ctrie implementation\r\nas compared with the [original](http://github.com/axel22/Ctries),\r\nwritten in Scala, result from the efforts I have taken to, where\r\nfeasible, adopt an approach emphasizing a more functional oriented\r\ndecomposition of the algortithm, written in a manner that is more\r\nclosely representative of ideomatic, common-lisp coding style.  For\r\nexample, rather than expose a general purpose GCAS and RDCSS api,\r\nthese protocols are incorporated into ctrie-specific abstractions. For\r\n__GCAS__ the exposed api includes: `INODE-READ` `INODE-MUTATE` and\r\n`INODE-COMMIT` and for __RDCSS:__ `ROOT-NODE-ACCESS`\r\n`ROOT-NODE-REPLACE` and `ROOT-NODE-COMMIT.` The liberties I have taken\r\nhave the intended benefit of providing an interface that is much\r\neasier to digest, understand, remember, and work with (at least for\r\nme) than direct exposure in imperative style of the intricate\r\nmechanations that underlie the ctrie algorithm.  On the other hand,\r\nthe further one strays from a direct translation of the original\r\n(verified) ctrie implementation, the greater the likelihood of\r\nintroducing bugs into an environment (lock-free concurrent data\r\nstructure development) in which bugs can be extremely subtle and\r\nnotoriously difficult to detect.  I have attempted to strike an\r\nappropriate balance between these conflicting concerns, and I intend\r\nto mitigate the risk, at least in part, through continued development\r\nof an extensive arsenal of regression tests and benchmarking\r\nfacilities.\r\n\r\nIn addition, there are a few differences in the feature set that\r\nis provided -- such as a suite of mapping operators in leiu of a\r\nJava-style Iterator.  For the most part I expect that these\r\nchanges will be preferable to developers accustomed to a more\r\n'lispy' coding style.\r\n\r\nFor additional insight into the specifics unique to this ctrie\r\nimplementation, an abbreviated reference to a number of internal\r\ndetails may be found in the section [Internal Reference](Internal\r\nReference) of this document, or, of course, by referring to\r\nthe [comprehensive documentation](doc/api/index.html) that is\r\nprovided as part of this distribution.\r\n\r\n\r\n### Source Files\r\n\r\nThe following outline provides a general description of the\r\nconstituent source files of the cl-ctrie repository and their\r\nrespective purpose.\r\n\r\n#### Required\r\n\r\nThe following files are the core sources currently necessary\r\nfor correct ctrie operation. \r\n\r\n- __`ctrie-package.lisp:`__  Package Definition\r\n- __`ctrie.lisp:`__          Structural Implementation\r\n- __`ctrie-util.lisp:`__     Supporting Utilities\r\n\r\n#### Supplemental\r\n\r\nThe following files define extended functionality, management,\r\nand analysis facilities supporting the development of CL-CTRIE.\r\n\r\n- `ctrie-cas.lisp:`   SBCL CAS extensions\r\n- `ctrie-lambda.lisp:` Experiments with Stateful Protocols\r\n- `ctrie-doc.lisp:`   Automated Documentation Support\r\n- `ctrie-test.lisp:`  Test and Performance Measurement\r\n\r\n### Performance\r\n\r\nTo date, the principal concern has been to fully achieve a working\r\nand robust implementation of the CTRIE algorithm, with only the\r\noccaisional profiling run from time to time in order to at least\r\nget a general sense of where the hot-spots are and peace of mind\r\nthat there are at least no glaring bottlenecks that seem out of\r\nhand.  A basic profiling exercise of the following activities is\r\nreported below.\r\n\r\n    1. construct a new ctrie instance\r\n    2. perform one-million insertions of (fixnum) key/value pairs\r\n    3. perform one-million lookups verifying retrieval of every value\r\n    4. perform one-million removals verifying proper contraction of the structure\r\n    5. verify the resulting ctrie is identical to when initially created.\r\n\r\n    \r\n```\r\n  seconds  |     gc     |    consed   |    calls   |  sec/call  |  name  \r\n--------------------------------------------------------------\r\n     1.331 |      1.001 | 332,691,664 |  2,198,622 |   0.000001 | MAKE-CNODE\r\n     1.123 |      0.000 |       1,904 |  3,179,578 |   0.000000 | CTHASH\r\n     0.871 |      0.000 |      44,608 |  5,344,350 |   0.000000 | ROOT-NODE-ACCESS\r\n     0.847 |      0.182 |  69,549,200 |  2,198,622 |   0.000000 | %MAKE-CNODE\r\n     0.820 |      0.000 |         576 | 12,582,934 |   0.000000 | FLAG\r\n     0.796 |      0.000 |         352 | 12,582,934 |   0.000000 | FLAG-ARC-POSITION\r\n     0.611 |      0.000 |         832 |  2,130,976 |   0.000000 | CTEQUAL\r\n     0.551 |      0.000 |      33,600 | 12,549,110 |   0.000000 | FLAG-PRESENT-P\r\n     0.529 |      0.000 |         720 |  5,344,350 |   0.000000 | FIND-CTRIE-ROOT\r\n     0.496 |      0.044 | 108,904,336 |  2,198,622 |   0.000000 | MAKE-REF\r\n     0.295 |      0.102 |  33,284,592 |  1,048,576 |   0.000000 | MAKE-SNODE\r\n     0.243 |      0.000 |         144 |  2,198,622 |   0.000000 | CTSTAMP\r\n     0.225 |      0.000 |         256 |  2,097,152 |   0.000000 | LEAF-NODE-KEY\r\n     0.216 |      0.118 |  32,803,552 |  1,048,576 |   0.000000 | CNODE-EXTENDED\r\n     0.189 |      0.000 |      32,848 |  2,097,152 |   0.000000 | LEAF-NODE-VALUE\r\n     0.146 |      0.000 |       1,872 |  1,048,576 |   0.000000 | SNODE\r\n     0.018 |      0.000 |           0 |     33,824 |   0.000001 | MAKE-INODE\r\n     0.016 |      0.000 |           0 |     34,257 |   0.000000 | RESURRECT\r\n     0.007 |      0.000 |   1,048,304 |     33,824 |   0.000000 | MAKE-TNODE\r\n     0.000 |      0.127 |  50,427,456 |  1,048,576 |   0.000000 | CTRIE-GET\r\n     0.000 |      0.000 |           0 |          1 |   0.000000 | CTRIE-SIZE\r\n     0.000 |      0.000 |       5,104 |  1,048,576 |   0.000000 | CTRIE-PUT\r\n     0.000 |      0.000 |           0 |          1 |   0.000000 | CTRIE-EMPTY-P\r\n     0.000 |      0.000 |           0 |          1 |   0.000000 | CTRIE-MAP\r\n     0.000 |      0.000 |      42,544 |  1,048,602 |   0.000000 | CTRIE-DROP\r\n     0.000 |      0.000 |           0 |          1 |   0.000000 | CTRIE-MAP-KEYS\r\n     0.000 |      0.000 |           0 |  1,116,226 |   0.000000 | MAP-NODE\r\n     0.000 |      0.000 |           0 |     33,824 |   0.000000 | ENTOMB\r\n     0.000 |      0.000 |           0 |     67,620 |   0.000000 | CNODE-UPDATED\r\n     0.000 |      0.000 |     268,496 |  4,160,480 |   0.000000 | %INSERT\r\n     0.000 |      0.000 |      39,024 |  2,164,798 |   0.000000 | INODE-COMMIT\r\n     0.000 |      0.000 |     342,688 |  4,160,556 |   0.000000 | %REMOVE\r\n     0.000 |      0.000 |         544 |     33,796 |   0.000000 | CLEAN-PARENT\r\n     0.000 |      0.000 |   1,375,952 |     33,824 |   0.000000 | %MAKE-INODE\r\n     0.000 |      0.000 |     262,352 |  4,194,304 |   0.000000 | %LOOKUP\r\n     0.000 |      0.000 |       3,504 |  1,048,576 |   0.000000 | CNODE-TRUNCATED\r\n     0.000 |      0.000 |           0 |         26 |   0.000000 | MAP-CNODE\r\n--------------------------------------------------------------\r\n     9.328 |      1.574 | 631,167,024 | 90,110,445 |            | Total\r\n```\r\n\r\n### Documentation\r\n\r\nComprehensive, HTML based [documentation](doc/api/index.html) may be\r\nfound at the project relative pathname `doc/api/index.html`.  In order\r\nto enable support for supplemental documentation related features, such\r\nas the ability to dynamically regenerate the provided documentation\r\nfiles incorporating all updates and changes as may be present in the\r\nsource code, a (lightly) enhanced distribution of CLDOC is required\r\nand may be obtained on [github](http://github.com/danlentz/cldoc).\r\n\r\nThe following sections provide a compact overview of the user api\r\nand a reference to some internal definitions of interest.\r\n\r\n#### User API Reference\r\n\r\nThe user api of cl-ctrie should be largely familiar to the average\r\ncommon-lisp programmer.  Nearly all exported symbols of the CL-CTRIE \r\npackage begin with the prefix \"ctrie\" and thus can be convenientely\r\nincorporated via USE-PACKAGE or equivalent package definition.  The\r\nfollowing definitions comprise a quick reference to the the public\r\nuser api:\r\n\r\n* * * * * *\r\n\r\n\r\n_[structure]_        `CTRIE ()`\r\n\r\n> A CTRIE structure is the root container that uniquely identifies a CTRIE\r\n  instance, and  contains the following perameters which specify the\r\n  definable aspects of each CTRIE:\r\n\r\n  - `READONLY-P` if not `NIL` prohibits any future modification or\r\n  cloning of this instance.\r\n  - `TEST` is a designator for an equality predicate that will be\r\n  applied to disambiguate and determine the equality of any two\r\n  keys. It is recommened that this value be a symbol that is fboundp,\r\n  to retain capability of externalization (save/restore). At present,\r\n  though, this is not enforced and a function object or lambda\r\n  expression will also be accepted, albeit without the ability of\r\n  save/restore.\r\n  - `HASH` is a designator for a hash function, which may be\r\n  desirable to customize when one has specific knowledge about the set\r\n  of keys which will populate the table.  At this time, a 32-bit hash\r\n  is recommended as this is what has been used for development and\r\n  testing and has been shown to provide good performance in\r\n  practice. As with `TEST` it is recommended that `HASH` be specified\r\n  by a symbol that is fboundp.\r\n  - `ROOT` is the slot used internally for storage of the root inode\r\n  structure that maintains the reference to the contents of the ctrie\r\n  proper.  The ctrie-root must only be accessed using the _RDCSS ROOT\r\n  NODE PROTOCOL_ defined by the top-level entry-points `ROOT-NODE-ACCESS`\r\n  and `ROOT-NODE-REPLACE`\r\n\r\n\r\n_[function]_         `MAKE-CTRIE  (&REST ARGS &KEY NAME ROOT (READONLY-P NIL)\r\n                                   (TEST 'EQUAL) (HASH 'SXHASH)\r\n                                   &ALLOW-OTHER-KEYS)`\r\n\r\n> CREATE a new CTRIE instance. This is the entry-point constructor \r\n  intended for use by the end-user.\r\n\r\n\r\n_[function]_         `CTRIE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type ctrie.\r\n\r\n\r\n_[function]_         `CTRIE-TEST  (CTRIE)`\r\n\r\n> Returns the test of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTRIE-HASH  (CTRIE)`\r\n\r\n> Returns the hash of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTRIE-READONLY-P  (CTRIE)`\r\n\r\n> Returns and (with setf) changes the readonly-p of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTRIE-PUT  (CTRIE KEY VALUE)`\r\n\r\n> Insert a new entry into CTRIE mapping KEY to VALUE.  If an entry\r\n  with key equal to KEY aleady exists in CTRIE, according to the\r\n  equality predicate defined by `CTRIE-TEST` then the priorbmapping\r\n  will be replaced by VALUE. Returns `VALUE` representing the\r\n  mapping in the resulting CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-GET  (CTRIE KEY)`\r\n\r\n> Find the entry in CTRIE whose key is KEY and returns the\r\n  associated value and T as multiple values, or returns NIL and NIL\r\n  if there is no such entry. Entries can be added using SETF.\r\n\r\n\r\n_[function]_         `CTRIE-DROP  (CTRIE KEY)`\r\n\r\n> Remove KEY and it's associated value from CTRIE. Returns as multiple\r\n  values the value associated with KEY and T if there was such an entry,\r\n  otherewise NIL and NIL\r\n\r\n\r\n_[macro]_            `CTRIE-DO  ((KEY VALUE CTRIE &KEY ATOMIC) &BODY BODY)`\r\n\r\n> Iterate over the contents of CTRIE in the manner of dolist. For each\r\n  (key . value) pair present in CTRIE, BODY (implicit PROGN) will be\r\n  evaluated with the symbols specified for KEY and VALUE will be bound\r\n  to the respective entry constituents.  A special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the CTRIE-DO\r\n  call.  If ATOMIC is non-NIL, the operation will be performed on a\r\n  read-only atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries present in CTRIE.\r\n  ```\r\n  ;;;  EXAMPLE: (ctrie-do (k v ctrie)\r\n  ;;;             (format t \"~&~8S => ~10S~%\" k v))\r\n  ```\r\n\r\n\r\n_[function]_         `CTRIE-MAP  (CTRIE FN &KEY ATOMIC &AUX ACCUM)`\r\n\r\n> Applies a function two arguments, FN, to each (key . value) pair present in\r\n  CTRIE.  During the extent of CTRIE-MAP, a special variable ACCUM (initially NIL)\r\n  is available for accumulation of a result value which will be returned after\r\n  the completion of the CTRIE-MAP call.  If ATOMIC is non-NIL, the operation will\r\n  be performed on a read-only atomic snapshot of CTRIE, which guarantees a\r\n  consistent, point-in-time representation of the entries present in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-MAP-KEYS  (CTRIE FN &KEY ATOMIC)`\r\n\r\n> Applies a function one argument, FN, to each key present in CTRIE.\r\n  During the extent of CTRIE-MAP-KEYS, a special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the\r\n  CTRIE-MAP-KEYS call.  If ATOMIC is non-NIL, the operation will be\r\n  performed on a read-only atomic snapshot of CTRIE, which guarantees\r\n  a consistent, point-in-time representation of the keys present in\r\n  CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-MAP-VALUES  (CTRIE FN &KEY ATOMIC)`\r\n\r\n> Applies a function one argument, FN, to each value present in CTRIE.\r\n  During the extent of CTRIE-MAP-VALUES, a special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the\r\n  CTRIE-MAP-VALUES call.  If ATOMIC is non-NIL, the operation will be\r\n  performed on a read-only atomic snapshot of CTRIE, which guarantees\r\n  a consistent, point-in-time representation of the values present in\r\n  CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-KEYS  (CTRIE &KEY ATOMIC)`\r\n\r\n> Construct and return a list containing all keys present in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the keys present in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-VALUES  (CTRIE &KEY ATOMIC)`\r\n\r\n> Construct and return a list containing all values present in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the values present in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-SIZE  (CTRIE &KEY ATOMIC &AUX (ACCUM 0))`\r\n\r\n> Return the number of entries present in CTRIE.  If ATOMIC is non-NIL,\r\n  the operation will be performed on a read-only atomic snapshot of CTRIE,\r\n  which guarantees a consistent, point-in-time representation of CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-CLEAR  (CTRIE)`\r\n\r\n> Atomically clear all entries stored in CTRIE, returning it to a condition\r\n  which returns `T` when tested with predicate `CTRIE-EMPTY-P`\r\n\r\n\r\n_[function]_         `CTRIE-PPRINT  (CTRIE &OPTIONAL (STREAM T))`\r\n\r\n> Pretty-print a representation of CTRIE as an alist containing\r\n  all (key . value) pairs found in it.  Atomicity is not guaranteed\r\n\r\n\r\n_[function]_         `CTRIE-TO-ALIST  (CTRIE &KEY ATOMIC)`\r\n\r\n> Return an alist containing all (key . value) pairs found in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-TO-HASHTABLE  (CTRIE &KEY ATOMIC HASH-TABLE &AUX\r\n                                           (ACCUM\r\n                                            (OR HASH-TABLE\r\n                                                (MAKE-HASH-TABLE :TEST\r\n                                                                 (CTRIE-TEST\r\n                                                                  CTRIE)\r\n                                                                 :HASH-FUNCTION\r\n                                                                 (CTRIE-HASH\r\n                                                                  CTRIE)\r\n                                                                 :SYNCHRONIZED\r\n                                                                 ATOMIC))))`\r\n\r\n> Return a hash-table containing all (key . value) pairs found in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries in CTRIE. If HASH-TABLE\r\n  is specified, it will be used as the destination hash-table.\r\n  Otherwise, a new hash-table will be created with hash-function and\r\n  test identical to that of CTRIE.  It will be created as synchronized\r\n  if ATOMIC is not NIL\r\n\r\n\r\n_[function]_         `CTRIE-FROM-HASHTABLE  (HASH-TABLE &KEY CTRIE)`\r\n\r\n> Return a CTRIE containing all (key . value) pairs found in HASH-TABLE.\r\n  If CTRIE is specified, it will be used as the destination ctrie.\r\n  Otherwise, a new ctrie will be created with test identical to that\r\n  of HASH-TABLE. The hash-function will NOT be preserved, as that\r\n  information does not appear to be recoverable from a hash-table once\r\n  created\r\n\r\n\r\n_[function]_         `CTRIE-FROM-ALIST  (ALIST &KEY CTRIE)`\r\n\r\n> Return a CTRIE containing all (key . value) pairs found in ALIST.\r\n  If CTRIE is specified, it will be used as the destination ctrie.\r\n  Otherwise, a new ctrie will be created. Atomicity is not guaranteed\r\n\r\n\r\n_[function]_         `CTRIE-EMPTY-P  (CTRIE)`\r\n\r\n> Return T if CTRIE contains no entries, otherwise NIL. This function is\r\n  O(1) and is much more efficient than testing for `CTRIE-SIZE` of 0\r\n\r\n\r\n_[function]_         `CTRIE-MAX-DEPTH  (THING)`\r\n\r\n> Compute the maximum length of any arc. Useful as a diagnostic\r\n\r\n\r\n_[function]_         `CTRIE-MIN-DEPTH  (THING)`\r\n\r\n> Compute the minimum length of any arc. Useful as a diagnostic\r\n\r\n\r\n_[function]_         `CTRIE-SNAPSHOT  (CTRIE &KEY READ-ONLY)`\r\n\r\n> Atomically create a clone of CTRIE that may be operated upon\r\n  independently without affecting or being affected by operations or\r\n  content of the original CTRIE.  If READ-ONLY is NIL (the default),\r\n  the new CTRIE will be a READABLE/WRITABLE 'fork' of CTRIE (see\r\n  `CTRIE-FORK`) otherwise, the clone will be READABLE only, which has\r\n  considerable performance benefits in some circumstances, as the arcs\r\n  will not require `REFRESH` and should be the preferred mode when\r\n  updates (writability) of the clone are not required\r\n\r\n\r\n_[function]_         `CTRIE-FORK  (CTRIE)`\r\n\r\n> Atomically create a READABLE and WRITABLE clone of CTRIE that may\r\n  be operated upon independently without affecting or being affected\r\n  by the original CTRIE.\r\n\r\n\r\n_[macro]_            `CTRIE-LAMBDA  (&ONCE CTRIE &REST REST)`\r\n\r\n> Pandoric Object and Inter-Lexical Communication Protocol\r\n  this macro builds the most unencumbered and widely applicable\r\n  'purist edition' Of our PLAMBDA based form.  Even as such,\r\n  a lot of care has been given to many subtle ways it has been\r\n  refined to offer the most convenient and natural tool possible.\r\n  ```;;;\r\n     ;;; (plambda (#<CLOSURE (LAMBDA (&REST ARGS)) {100929EB1B}> )\r\n     ;;;\r\n     ;;; DISPATCHING to FUNCTIONAL MAPPING:\r\n     ;;;   (IF (REST ARGS)\r\n     ;;;          (APPLY ARG (REST ARGS))\r\n     ;;;          (FUNCALL ARG #'IDENTITY)) =>\r\n     ;;; ------------------------------------------------------------\r\n     ;;; INITIALIZING PLAMBDA\r\n     ;;; ------------------------------------------------------------\r\n     ;;;   IT => #S(CTRIE\r\n     ;;;               :READONLY-P NIL\r\n     ;;;               :TEST EQUAL\r\n     ;;;               :HASH SXHASH\r\n     ;;;               :STAMP #<CLOSURE (LAMBDA # :IN CONSTANTLY) {10092B516B}>\r\n     ;;;               :ROOT #S(INODE\r\n     ;;;                        :GEN #:|ctrie2196|\r\n     ;;;                        :REF #S(REF\r\n     ;;;                                :STAMP @2012-08-19T13:34:58.314457-04:00\r\n     ;;;                                :VALUE #S(CNODE :BITMAP 0 :ARCS #())\r\n     ;;;                                :PREV NIL)))\r\n     ;;;   PLIST => (:CONTAINER #<CLOSURE (LAMBDA #) {100929EACB}> \r\n     ;;;             :TIMESTAMP @2012-08-19T13:34:58.314464-04:00)\r\n     ;;;   STACK => (#<CLOSURE (LAMBDA #) {100929EACB}>)\r\n     ;;; \r\n     ;;; ------------------------------------------------------------\r\n     ;;;  #<CLOSURE (LAMBDA (&REST #:ARGS55)) {100929EACB}>\r\n     ;;;```\r\n\r\n\r\n_[generic-function]_ `CTRIE-LAMBDA-CTRIE  (CTRIE-LAMBDA-OBJECT)`\r\n\r\n> Returns and (with setf) changes the ctrie of the specified ctrie-lambda-object\r\n\r\n\r\n\r\n_[function]_         `CTRIE-LAMBDA-SPAWN  (SELF &KEY READ-ONLY)`\r\n\r\n> Causes the atomic clone of enclosed ctrie structure and builds a new\r\n  lexical closure to operate on it.  Does not bother to reproduce fancy\r\n  (expensive) object, class, bindings, but provides almost identical\r\n  functionality.  May be used to more efficintly distribute workload\r\n  in parallel\r\n\r\n\r\n_[macro]_            `DEFINE-CTRIE  (NAME CTRIE &REST ARGS &KEY (OBJECT T) SPEC)`\r\n\r\n> Define a 'functional' __CTRIE-LAMBDA__ that combines all the the\r\n  capabilities of the raw data structure with behavior and semantics\r\n  one would expect of any other ordinary common-lisp function.  The\r\n  resulting symbol defined as 'name will be bound in three distinct\r\n  namespaces: the `SYMBOL-VALUE` will be bound to the LAMBDA CLOSURE\r\n  object, `SYMBOL-FUNCTION` (fdefinition) will be FBOUND to the\r\n  compiled function, and the corresponding '(SETF NAME) form will be\r\n  SETF-BOUND.  the syntax for invoking NAME is as in a LISP1; i.e., no\r\n  'funcall' is required (but still works if you prefer).\r\n  Calling `(NAME key)` returns the value mapped to key, or `NIL` just\r\n  as if by `(CTRIE-GET ctrie-name key).` Analogously when used as a\r\n  setf-able place such as by `(setf (NAME key) value)` it has the\r\n  equivalent behavior to the operation `(CTRIE-PUT ctrie-name key\r\n  value).` Use of this type of binding technique has some really\r\n  convenient effects that I've quickly started to become quite fond\r\n  of.  One such idiom, for example, `(mapcar MY-CTRIE '(key1 key2 key3\r\n  key4 ...))` returns a list containing all the mapped values\r\n  corresponding to the respective keys.  One additional feature that\r\n  I've found extremely useful is included _under the hood:_ Invoking\r\n  MY-CTRIE on an object of type FUNCTION will not search the ctrie for\r\n  an entry having that function ast its key, but will instead APPLY\r\n  that function to the actual CTRIE structure wrapped within the\r\n  closure.  Thus, `(MY-CTRIE #'identity)` will return the underlying\r\n  ctrie as just an ordinary instance of a CTRIE STRUCTURE.  \r\n  There are many other functions this is handy with, like\r\n  `(MY-CTRIE #'ctrie-size)` `(MY-CTRIE #'ctrie-to-hashtable)`\r\n  etc.  Some additional examples are provided below.\r\n  ```\r\n  ;;;  (define-ctrie my-ctrie)\r\n  ;;;    =>  MY-CTRIE\r\n  ;;;\r\n  ;;;  (describe 'my-ctrie)\r\n  ;;;\r\n  ;;;     CL-CTRIE::MY-CTRIE\r\n  ;;;       [symbol]\r\n  ;;;    \r\n  ;;;     MY-CTRIE names a special variable:\r\n  ;;;       Value: #<CLOSURE (LAMBDA # :IN MAKE-CTRIE-LAMBDA) {100F73261B}>\r\n  ;;;    \r\n  ;;;     MY-CTRIE names a compiled function:\r\n  ;;;       Lambda-list: (&REST ARGS1)\r\n  ;;;       Derived type: FUNCTION\r\n  ;;;    \r\n  ;;;     (SETF MY-CTRIE) names a compiled function:\r\n  ;;;       Lambda-list: (VALUE KEY)\r\n  ;;;       Derived type: (FUNCTION (T T) *)\r\n  ;;;\r\n  ;;;\r\n  ;;;   (my-ctrie :HONG-KONG :FOOY)\r\n  ;;;     =>  :FOOY\r\n  ;;;\r\n  ;;;   (my-ctrie :HONG-KONG)\r\n  ;;;     =>  :FOOY ; T\r\n  ;;;\r\n  ;;;   (map 'list #'eval (mapcar #`(my-ctrie ,a1 ,a1) (iota 12)))\r\n  ;;;     =>  (0 1 2 3 4 5 6 7 8 9 10 11)\r\n  ;;;\r\n  ;;;   (mapcar my-ctrie (iota 12))\r\n  ;;;     =>  (0 1 2 3 4 5 6 7 8 9 10 11)\r\n  ```\r\n\r\n\r\n_[macro]_            `CTRIE-ERROR  (CONDITION &REST ARGS)`\r\n\r\n> Signal a CTRIE related condition.\r\n\r\n\r\n_[condition]_        `CTRIE-ERROR (ERROR)`\r\n\r\n> Abstract superclass of CTRIE related conditions.\r\n\r\n\r\n_[condition]_        `CTRIE-STRUCTURAL-ERROR (CTRIE-ERROR)`\r\n\r\n> Condition designating that the CTRIE data structure\r\n   has been determined to be invalid.\r\n\r\n\r\n_[condition]_        `CTRIE-OPERATIONAL-ERROR (CTRIE-ERROR)`\r\n\r\n> Condition for when an operational failure or\r\n  inconsistency has occurred.\r\n\r\n\r\n_[condition]_        `CTRIE-OPERATION-RETRIES-EXCEEDED (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> Condition indicating an operation has failed the\r\n   maximum number of times specified by the special-variable\r\n   *retries*\r\n\r\n\r\n_[condition]_        `CTRIE-NOT-IMPLEMENTED (CTRIE-ERROR)`\r\n\r\n> Condition designating functionality for which the\r\n   implementation has not been written, but has not been deliberately\r\n   excluded.\r\n\r\n\r\n_[condition]_        `CTRIE-NOT-SUPPORTED (CTRIE-ERROR)`\r\n\r\n> Condition designating functionality that is\r\n  deliberately not supported.\r\n\r\n\r\n_[condition]_        `CTRIE-INVALID-DYNAMIC-CONTEXT (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> Condition indicating an operation was attempted\r\n   outside the dynamic extent of a valid enclosing WITH-CTRIE form\r\n\r\n\r\n_[condition]_        `CTRIE-GENERATIONAL-MISMATCH (CTRIE-STRUCTURAL-ERROR)`\r\n\r\n> Condition indicating an operation encountered an\r\n   outdated or inconsistent node during its attempted traversal\r\n\r\n\r\n_[function]_         `CTRIE-MODIFICATION-FAILED  (REASON &KEY OP PLACE)`\r\n\r\n> Signal a modification failure with the appropriate attendant metadata.\r\n\r\n\r\n_[condition]_        `CTRIE-MODIFICATION-FAILED (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> This condition indicates an unhandled failure of an attempt to\r\n         perform stateful modification to CTRIE.  The most common case in\r\n         which this might occur is when such an attempt is mode on a CTRIE\r\n         designated as READONLY-P.  In any case, this condition represents an\r\n         exception from which processing cannot continue and requires\r\n         interactive user intervention in order to recover.\r\n\r\n\r\n* * * * * *\r\n\r\n#### Internal Reference (abridged)\r\n\r\nThe following reference describes some selected internal\r\nimplementation details of interest.  Under normal circumstances it\r\nshould not be necessary to interact with these unexported symbols\r\nunless developing an extension to cl-ctrie, but are presented here for\r\nthe sake of convenience, in order to provide better insight into the ctrie\r\nstructure in general, and to help illuminate significant aspects of this\r\nimplementation in particular.  As mentioned above, [comprehensive\r\ndocumentation](doc/api/index.html) of all symbols is also provided,\r\nand should be considered the authoratative reference to the CL-CTRIE\r\nimplementation.\r\n\r\n* * * * * * *\r\n\r\n\r\n_[special-variable]_ `*CTRIE*  (NIL)`\r\n\r\n> Within the dynamic extent of a CTRIE operation this variable will\r\n  be bound to the root-container CTRIE operand.  It is an error if an\r\n  operation is defined that attempts access to a CTRIE without this\r\n  binding, which is properly established by wrapping the operation in\r\n  an appropriate WITH-CTRIE form.\r\n\r\n\r\n_[special-variable]_ `*RETRIES*  (16)`\r\n\r\n> Establishes the number of restarts permitted to a CTRIE operation\r\n  established by a WITH-CTRIE form before a condition of type\r\n  CTRIE-OPERATION-RETRIES-EXCEEDED will be signaled, aborting the\r\n  operatation, and requiring operator intervention to resume\r\n  processing.\r\n\r\n\r\n_[special-variable]_ `*TIMEOUT*  (2)`\r\n\r\n> Establishes the duration (in seconds) allotted to a CTRIE operation\r\n  established by a WITH-CTRIE form before a condition of type\r\n  CTRIE-OPERATION-TIMEOUT-EXCEEDED will be signaled, aborting the\r\n  operatation, and requiring operator intervention to resume\r\n  processing.\r\n\r\n\r\n_[special-variable]_ `*HASH-CODE*  (NIL)`\r\n\r\n> Special variable used to store the hash-code that corresponds to the\r\n  current operation.  Used as a means of improving efficiency by eliminating\r\n  needless recomputation of the hash function, which is the most expensive\r\n  part of most user-level ctrie operations.  If this value is not set, then\r\n  the hash will simply be computed on demand and processing will continue\r\n  unaffected.  Use of this variable is simply an optional performace\r\n  optimization techniqie.\r\n\r\n\r\n_[macro]_            `MULTI-CATCH  (TAG-LIST &BODY FORMS)`\r\n\r\n> Macro allowing catch of multiple tags at once and\r\n    finding out which tag was thrown.\r\n    * RETURNS: (values RESULT TAG)\r\n       -  RESULT is either the result of evaluationg FORMS or the value\r\n          thrown by the throw form.\r\n       -  TAG is NIl if evaluation of the FORMS completed normally\r\n          or the tag thrown and cought.\r\n    * EXAMPLE:\r\n    ```\r\n        ;;; (multiple-value-bind (result tag)\r\n        ;;;            (multi-catch (:a :b)\r\n        ;;;                 ...FORMS...)\r\n        ;;;              (case tag \r\n        ;;;                 (:a ...)\r\n        ;;;                 (:b ...)\r\n        ;;;                 (t ...)))\r\n    ```\r\n\r\n\r\n_[macro]_            `CATCH-CASE  (FORM &REST CASES)`\r\n\r\n> User api encapsulating the MULTI-CATCH control-structure in a\r\n    syntactic format that is identical to that of the familiar CASE\r\n    statement, with the addition that within the scope of each CASE\r\n    clause, a lexical binding is established between the symbol IT and\r\n    the value caught from the throw form.\r\n\r\n\r\n_[structure]_        `CTRIE ()`\r\n\r\n> A CTRIE structure is the root container that uniquely identifies a CTRIE\r\n  instance, and  contains the following perameters which specify the\r\n  definable aspects of each CTRIE:\r\n\r\n  - `READONLY-P` if not `NIL` prohibits any future modification or\r\n  cloning of this instance.\r\n  - `TEST` is a designator for an equality predicate that will be\r\n  applied to disambiguate and determine the equality of any two\r\n  keys. It is recommened that this value be a symbol that is fboundp,\r\n  to retain capability of externalization (save/restore). At present,\r\n  though, this is not enforced and a function object or lambda\r\n  expression will also be accepted, albeit without the ability of\r\n  save/restore.\r\n  - `HASH` is a designator for a hash function, which may be\r\n  desirable to customize when one has specific knowledge about the set\r\n  of keys which will populate the table.  At this time, a 32-bit hash\r\n  is recommended as this is what has been used for development and\r\n  testing and has been shown to provide good performance in\r\n  practice. As with `TEST` it is recommended that `HASH` be specified\r\n  by a symbol that is fboundp.\r\n  - `ROOT` is the slot used internally for storage of the root inode\r\n  structure that maintains the reference to the contents of the ctrie\r\n  proper.  The ctrie-root must only be accessed using the _RDCSS ROOT\r\n  NODE PROTOCOL_ defined by the top-level entry-points `ROOT-NODE-ACCESS`\r\n  and `ROOT-NODE-REPLACE`\r\n\r\n\r\n_[function]_         `CTRIE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type ctrie.\r\n\r\n\r\n_[function]_         `CTRIE-HASH  (CTRIE)`\r\n\r\n> Returns the hash of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTRIE-TEST  (CTRIE)`\r\n\r\n> Returns the test of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTRIE-READONLY-P  (CTRIE)`\r\n\r\n> Returns and (with setf) changes the readonly-p of the specified ctrie\r\n\r\n\r\n\r\n_[function]_         `CTHASH  (KEY)`\r\n\r\n> Compute the hash value of KEY using the hash function defined by\r\n  the CTRIE designated by the innermost enclosing WITH-CTRIE form.\r\n\r\n\r\n_[function]_         `CTEQUAL  (X Y)`\r\n\r\n> Test the equality of X and Y using the equality predicate defined\r\n  by the CTRIE designated by the innermost enclosing WITH-CTRIE form.\r\n\r\n\r\n_[macro]_            `WITH-CTRIE  (&ONCE CTRIE &BODY BODY)`\r\n\r\n> Configure the dynamic environment with the appropriate condition\r\n  handlers, control fixtures, and instrumentation necessary to execute\r\n  the operations in BODY on the specified CTRIE. Unless specifically\r\n  documented, the particular configuration of this dynamic environment\r\n  should be considered an implementation detail and not relied upon. A\r\n  particular exception, however, is that within the dynamic extent of\r\n  a WITH-CTRIE form, the code implementing a CTRIE operation may\r\n  expect that the special variable `*CTRIE*` will be bound to the root\r\n  container of subject CTRIE.  See also the documentation for\r\n  `*CTRIE*`\r\n\r\n\r\n_[function]_         `FLAG  (KEY LEVEL &OPTIONAL USE-CACHED-P)`\r\n\r\n> For a given depth, LEVEL, within a CTRIE, extract the correspondant\r\n  sequence of bits from the computed hash of KEY that indicate the\r\n  logical index of the arc on the path to which that key may be found.\r\n  If USE-CACHED-P is non-NIL and the special-variable `*HASH-CODE*` is\r\n  non-NIL as well, the hash will not be recomputed, but instead the\r\n  value bound to `*HASH-CODE*` will be used as an optimization to\r\n  reduce unnecessary recomputation of hash function -- an expensive\r\n  operation.  This value is NOT checked and assumed to be valid and\r\n  appropriate to the given situation -- care must be taken to use this\r\n  cached value correctly.  When in doubt, recomputing hash may be a\r\n  performance penalty, but is guaranteed to always work in any\r\n  situation.  Note that the logical index of the arc is most likely\r\n  not the same as the physical index where it is actually located --\r\n  for that see `FLAG-ARC-POSITION`\r\n\r\n\r\n_[function]_         `FLAG-PRESENT-P  (FLAG BITMAP)`\r\n\r\n> Tests the (fixnum) BITMAP representing the logical index of all\r\n  arcs present in a CNODE for the presence of a particular arc whose\r\n  logical index is represented by FLAG.\r\n\r\n\r\n_[function]_         `FLAG-ARC-POSITION  (FLAG BITMAP)`\r\n\r\n> Given FLAG representing the logical index of an arc, and BITMAP\r\n  representing all arcs present, compute a physical index for FLAG in\r\n  such a manner as to always ensure all arcs map uniquely and\r\n  contiguously to the smallest vector that can contain the given\r\n  arcs.\r\n\r\n\r\n_[function]_         `FLAG-VECTOR  (&OPTIONAL (CONTENT 0))`\r\n\r\n> FLAG-VECTOR is a bit-vector representation of the (fixnum)\r\n  BITMAP. It is currently not used for any calculation, however it is\r\n  included within each CNODE as a convenience because it makes it\r\n  immediately clear from visual inspection which logical arc indexes\r\n  are represented in the node. For example, from the bit-vector\r\n  `#*10010000000000000000000000000000` one can easily see that the first\r\n  and fourth positions are occupied, and the rest empty.\r\n\r\n\r\n_[structure]_        `REF ()`\r\n\r\n> Atomically Stamped Reference structure _[Herlithy, TAOMP]_ that\r\n  encapsulates the mutable slots within an inode. Any specific `REF`\r\n  structure is, itself, never mutated.  Using the `REF` structure\r\n  as basis of inode implementation provides the capability to 'bundle'\r\n  additional metadata in an inode while still providing atomic compare\r\n  and swap using a single comparison of the aggregate `REF` instance.\r\n   - `STAMP` defines a slot containing implementation-specific metadata\r\n     that may be maintained internally as a means of tracking inode\r\n     modification and update behavior.  It should not be referenced by\r\n     user code, and the format of its contents should not be relied apon.\r\n   - `VALUE` defines a slot that contains a reference to the MAIN-NODE\r\n     that the enclosing inode should be interpreted as 'pointing to'\r\n   - `PREV` defines a slot which, during the `INODE-COMMIT` phase of the\r\n     _GCAS INODE PROTOCOL_ maintains a reference to the last valid\r\n     inode state, which may be restored, if necessary, during the\r\n     course of the `INODE-READ` / `INODE-COMMIT` arbitration process\r\n\r\n\r\n_[function]_         `REF-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type ref.\r\n\r\n\r\n_[function]_         `REF-STAMP  (REF)`\r\n\r\n> Returns the stamp of the specified ref\r\n\r\n\r\n\r\n_[function]_         `REF-VALUE  (REF)`\r\n\r\n> Returns the value of the specified ref\r\n\r\n\r\n\r\n_[function]_         `REF-PREV  (REF)`\r\n\r\n> Returns and (with setf) changes the prev of the specified ref\r\n\r\n\r\n\r\n_[structure]_        `FAILED-REF (REF)`\r\n\r\n> A `FAILED-REF` is a structure that is used to preserve the linkage to\r\n  prior inode state following a failed GCAS.  Any inode access that\r\n  detects a `FAILED-REF` will immediately invoke a commit to restore the\r\n  inode to the state recorded in `FAILED-REF-PREV`\r\n\r\n\r\n_[function]_         `FAILED-REF-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type failed-ref.\r\n\r\n\r\n_[type]_             `LEAF-NODE  NIL`\r\n\r\n> A LEAF-NODE represents a terminal value in a CTRIE arc.\r\n  LEAF-NODEs always contain a unit-payload of CTRIE data\r\n  storage; For example, an SNODE contains a key/value pair.\r\n\r\n\r\n_[type]_             `BRANCH-NODE  NIL`\r\n\r\n> a BRANCH-NODE represents a single arc typically contained\r\n  within A CNODE.\r\n\r\n\r\n_[type]_             `MAIN-NODE  NIL`\r\n\r\n> A MAIN-NODE is a node that typically represents a specific\r\n  depth or level within the ctrie and is referenced\r\n  by its own unique inode.\r\n\r\n\r\n_[structure]_        `INODE ()`\r\n\r\n> An INODE, or 'Indirection Node' is the mutable structure\r\n  representing the link between other 'main-node' structures found in\r\n  a ctrie.  An inode is the only type of node that may change the\r\n  value of its content during its lifetime.  In this implementation,\r\n  all such values as may change are encapsulated within a `REF`\r\n  substructure.  Each inode also contains a generational descriptor\r\n  object, comparible by identity only, which is used to identify the\r\n  state of synchronization between the inode and the current\r\n  'generation' indicated by the root inode at the base of the\r\n  CTRIE. As an inode may not change its 'gen identity' during its\r\n  lifetime, this disparity with the generation of the root node will\r\n  immediately result in the replacement of the inode with a new one\r\n  properly synchronized with the root's `GEN` object. In this\r\n  implementation, `GEN` objects are implemented by GENSYMS -- unique,\r\n  uninterned symbols which inherently provide very similar symantics\r\n  to those required of the generational descriptor.\r\n  - `GEN` defines a slot containing a generational descriptor object\r\n  - `REF` defines a slot containing a `REF` struct that encapsulates\r\n    the mutable content within an INODE\r\n\r\n\r\n_[function]_         `INODE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type inode.\r\n\r\n\r\n_[function]_         `INODE-GEN  (INODE)`\r\n\r\n> Returns the gen of the specified inode\r\n\r\n\r\n\r\n_[function]_         `INODE-REF  (INODE)`\r\n\r\n> Returns and (with setf) changes the ref of the specified inode\r\n\r\n\r\n\r\n_[function]_         `MAKE-INODE  (LINK-TO &OPTIONAL GEN STAMP PREV)`\r\n\r\n> Construct a new INODE that represents a reference to the value\r\n  provided by argument LINK-TO, optionally augmented with a specified\r\n  generational descriptor, timestamp, and/or previous state\r\n\r\n\r\n_[macro]_            `GCAS-COMPARE-AND-SET  (OBJ EXPECTED NEW EXPECTED-STAMP\r\n                                             NEW-STAMP PREV)`\r\n\r\n> A thin, macro layer abstraction over the basic compare-and-swap\r\n  primitive which provides a consistent interface to the underlying\r\n  inode structure and manages additional metadata, providing\r\n  reasonable defaults when they are not specified.\r\n\r\n\r\n_[function]_         `INODE-READ  (INODE)`\r\n\r\n> INODE-READ provides the top-level interface to the inode _GCAS ACCESS_\r\n  api, which is the mechanism which must be used to gain access to the\r\n  content of any NON-ROOT inode. For access to the root inode, refer\r\n  to the RDCSS inode api `ROOT-NODE-ACCESS`. Returns as four values,\r\n  the MAIN-NODE, the STAMP, the PREVIOUS STATE (if any), and the REF\r\n  structure encapsulated by the inode.\r\n\r\n\r\n_[function]_         `INODE-MUTATE  (INODE OLD-VALUE NEW-VALUE)`\r\n\r\n> INODE-MUTATE provides the top-level interface to the inode _GCAS\r\n  MODIFICATION_ api, which is the mechanism which must be used to\r\n  effect any change in a NON-ROOT inode.  For modification of the\r\n  root-inode, refer to the `ROOT-NODE-REPLACE` _RDCSS ROOT NODE\r\n  PROTOCOL_ Returns a boolean value which indicates the success or\r\n  failure of the modification attempt.\r\n\r\n\r\n_[function]_         `INODE-COMMIT  (INODE REF)`\r\n\r\n> INODE-COMMIT implements the _GCAS COMMIT_ protocol which is invoked\r\n  as necessary by the `INODE-READ` and `INODE-MUTATE` entry-points.  It is\r\n  not meant to be invoked directly, as this would most likely result\r\n  in corruption. Returns the `REF` structure representing the content of\r\n  whatever root inode wound up successfully committed -- either the\r\n  one requested, or one represented by a previous valid state.  In order\r\n  to coexist with the _RDCSS ROOT NODE PROTOCOL_ this GCAS COMMIT\r\n  implementation is augmented with RDCSS ABORTABLE READ semantics\r\n  by a forward reference to a RDCSS-aware `ROOT-NODE-ACCESS` in order\r\n  to safely compare INODE's generational descriptor with the one found\r\n  in the root inode of the subject CTRIE.\r\n\r\n\r\n_[function]_         `SNODE  (KEY VALUE)`\r\n\r\n> Construct a new SNODE which represents the mapping from\r\n  domain-element KEY to range-element VALUE.\r\n\r\n\r\n_[structure]_        `SNODE ()`\r\n\r\n> SNODE, i.e., 'Storage Node', is the LEAF-NODE structure ultimately\r\n  used for the storage of each key/value pair contained in the CTRIE.\r\n  An SNODE is considered to be immutable during its lifetime.\r\n   - `KEY` defines the slot containing an element of the map's domain.\r\n   - `VALUE` defines the slot containing the range-element mapped to `KEY`\r\n\r\n\r\n_[function]_         `SNODE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type snode.\r\n\r\n\r\n_[function]_         `SNODE-KEY  (SNODE)`\r\n\r\n> Returns the key of the specified snode\r\n\r\n\r\n\r\n_[function]_         `SNODE-VALUE  (SNODE)`\r\n\r\n> Returns the value of the specified snode\r\n\r\n\r\n\r\n_[structure]_        `LNODE ()`\r\n\r\n> LNODE, i.e., 'List Node', is a special structure used to enclose\r\n  SNODES in a singly-linked chain when the hash-codes of the\r\n  respective SNODE-KEYS collide, but those keys are determined to be\r\n  unique by the `CTRIE-TEST` function defined for that ctrie.  An\r\n  LNODE (and therefore a chain of LNODEs) is considered to be\r\n  immutable during its lifetime.  The order of the list is\r\n  implemented (arbitrarily) as most recently added first, analogous to\r\n  `CL:PUSH`\r\n   - `ELT` defines the slot containing an enclosed SNODE\r\n   - `NEXT` defines a slot referencing the next LNODE in the chain, or\r\n     `NIL` if no further LNODES remain.\r\n\r\n\r\n_[function]_         `LNODE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type lnode.\r\n\r\n\r\n_[function]_         `LNODE-ELT  (LNODE)`\r\n\r\n> Returns the elt of the specified lnode\r\n\r\n\r\n\r\n_[function]_         `LNODE-NEXT  (LNODE)`\r\n\r\n> Returns the next of the specified lnode\r\n\r\n\r\n\r\n_[function]_         `ENLIST  (&REST REST)`\r\n\r\n> Construct a chain of LNODE structures enclosing the values supplied.\r\n  It is assumed (elsewhere) that each of these values is a valid SNODE\r\n  structure.\r\n\r\n\r\n_[function]_         `LNODE-REMOVED  (ORIG-LNODE KEY TEST)`\r\n\r\n> Construct a chain of LNODE structures identical to the chain starting\r\n  with ORIG-LNODE, but with any LNODE containing an SNODE equal to KEY\r\n  removed.  Equality is tested as by the predicate function passed as\r\n  the argument TEST. The order of nodes in the resulting list will\r\n  remain unchanged.\r\n\r\n\r\n_[function]_         `LNODE-INSERTED  (ORIG-LNODE KEY VALUE TEST)`\r\n\r\n> Construct a chain of LNODE structures identical to the chain starting\r\n  with ORIG-LNODE, but ensured to contain an LNODE enclosing an SNODE mapping\r\n  KEY to VALUE.  If the given KEY equal to a key already present somewhere\r\n  in the chain (as compared with equality predicate TEST) it will be\r\n  replaced.  Otherwise a new LNODE will be added. In either case, the LNODE\r\n  containing `(SNODE KEY VAlUE)` will be the first node in the resulting\r\n  list\r\n\r\n\r\n_[function]_         `LNODE-SEARCH  (LNODE KEY TEST)`\r\n\r\n> Within the list of lnodes beginning with LNODE, return the range value\r\n  mapped by the first SNODE containing a key equal to KEY as determined\r\n  by equality predicate TEST, or `NIL` if no such key is found.  As a\r\n  second value, in order to support storage of `NIL` as a key, return `T` to\r\n  indicate that the KEY was indeed found during search, or `NIL` to indicate\r\n  that no such key was present in the list\r\n\r\n\r\n_[function]_         `LNODE-LENGTH  (LNODE)`\r\n\r\n> Return the number of LNODES present in the chain beginning at LNODE\r\n\r\n\r\n_[structure]_        `TNODE ()`\r\n\r\n> A TNODE, or 'Tomb Node', is a special node structure used to preserve\r\n  ordering during `CTRIE-DROP` (`%remove`) operations.\r\n  Any time a TNODE is encountered during the course of a `CTRIE-GET` (`%lookup`)\r\n  operation, the operative thread is required to invoke a `CLEAN` operation\r\n  on the TNODE it has encountered and throw to `:RESTART` its lookup activity\r\n  over again.  A TNODE is considered to be immutable and may not change its\r\n  value during its lifetime.\r\n   - `CELL` defines a slot which contains the entombed node structure.\r\n      Only LNODE and SNODE type nodes are ever entombed\r\n\r\n\r\n_[function]_         `TNODE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type tnode.\r\n\r\n\r\n_[function]_         `TNODE-CELL  (TNODE)`\r\n\r\n> Returns the cell of the specified tnode\r\n\r\n\r\n\r\n_[structure]_        `CNODE ()`\r\n\r\n> A CNODE, or 'Ctrie Node' is a MAIN-NODE containing a vector of up\r\n  to `2^W` 'arcs' -- i.e., references to either an SNODE or INODE\r\n  structure, collectively referred to as `BRANCH-NODES.` Each CNODE\r\n  also contains a (fixnum) bitmap that describes the layout of which\r\n  logical indices within the total capacity of `2^W` arcs are actually\r\n  allocated within that node with BRANCH-NODES physically present.\r\n  For more specific details on these BITMAP and ARC-VECTOR\r\n  constituents, refer to the following related functions: `FLAG`\r\n  `FLAG-PRESENT-P` `FLAG-VECTOR` and `FLAG-ARC-POSITION. The CNODE\r\n  structure is considered to be immutable and arcs may not be added or\r\n  removed during its lifetime.  The storage allocated within a CNODE\r\n  is fixed and specified at the time of its creation based on the\r\n  value of BITMAP during initialization\r\n   - `BITMAP`\r\n   - `ARCS` \r\n\r\n\r\n_[function]_         `CNODE-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type cnode.\r\n\r\n\r\n_[function]_         `MAKE-CNODE  (&OPTIONAL (BITMAP 0))`\r\n\r\n> Construct a CNODE with internal storage allocated for the number of\r\n  arcs equal to the Hamming-Weight of the supplied BITMAP parameter.\r\n  If no BITMAP is provided, the CNODE created will be empty -- a state\r\n  which is only valid for the level 0 node referenced by the root of\r\n  the CTRIE.  This constructor is otherwise never called directly, but\r\n  is invoked during the course of higher-level operations such as\r\n  `CNODE-EXTENDED` `CNODE-UPDATED` `CNODE-TRUNCATED` and `MAP-CNODE`\r\n\r\n\r\n_[function]_         `CNODE-EXTENDED  (CNODE FLAG POSITION NEW-ARC)`\r\n\r\n> Construct a new cnode structure that is exactly like CNODE, but\r\n  additionally contains the BRANCH-NODE specified by parameter NEW-ARC\r\n  and logical index FLAG at the physical index POSITION within its\r\n  vector of allocated arcs.  The BITMAP of this new CNODE will be\r\n  calculated as an adjustment of the prior CNODE's BITMAP to reflect\r\n  the presence of this additional arc.  In addition, the physical\r\n  index within the extended storage vector for the other arcs present\r\n  may also change with respect to where they were located in the prior\r\n  CNODE.  In other words, the physical index of a given arc within the\r\n  compressed CNODE storage vector should never be relied upon\r\n  directly, it should always be accessed by calculation based on its\r\n  LOGICAL index and the current CNODE BITMAP as described in more\r\n  detail by the documentation for the functions `FLAG` `FLAG-VECTOR` and\r\n  `FLAG-ARC-POSITION`\r\n\r\n\r\n_[function]_         `CNODE-UPDATED  (CNODE POSITION REPLACEMENT-ARC)`\r\n\r\n> Construct a new cnode structure identical to CNODE, but having the\r\n  BRANCH-NODE physically located at POSITION within the storage\r\n  vector replaced by the one specified by REPLACEMENT-ARC.  Unlike\r\n  `CNODE-EXTENDED` and `CNODE-TRUNCATED` the allocated storage and\r\n  existing BITMAP of this CNODE will remain unchanged (as this is\r\n  simply a one-for-one replacement) and correspondingly, no reordering\r\n  of other nodes within the storage vector will occur\r\n\r\n\r\n_[function]_         `CNODE-TRUNCATED  (CNODE FLAG POS)`\r\n\r\n> Construct a new cnode structure that is exactly like CNODE, but\r\n with the arc at logical index FLAG and physical storage vector\r\n location POS removed.  The new CNODE will have an updated bitmap\r\n value that is adusted to reflect the removal of this arc, and the\r\n position of other arcs within the storage vector of the new CNODE\r\n will be adjusted in a manner analogous to that of `CNODE-EXTENDED`\r\n More details on this process may be found by referring to the\r\n documentation for the functions `FLAG` `FLAG-VECTOR` and\r\n `FLAG-ARC-POSITION`\r\n\r\n\r\n_[function]_         `MAP-CNODE  (FN CNODE)`\r\n\r\n> Construct a new cnode structure that is exactly like CNODE, but\r\n  with each arc (BRANCH-NODE) present in CNODE replaced by the result\r\n  of applying FN to that arc.  I.e., a simple functional mapping from\r\n  the old CNODE by FN.  As with `CNODE-UPDATED` the allocated storage and\r\n  BITMAP of the resulting CNODE will remain unchanged from the\r\n  original, and no physical reordering of nodes within the storage\r\n  vector will occur\r\n\r\n\r\n_[function]_         `CNODE-CONTRACTED  (CNODE LEVEL)`\r\n\r\n> The _CONTRACTION_ of a CNODE is an ajustment performed when a CNODE\r\n  at depth other than level 0 contains only a single SNODE arc.  In\r\n  such a case, that SNODE is entombed in a new TNODE, which is\r\n  returned as the result of the CNODE contraction. In all other cases\r\n  the CNODE is simply returned as-is.  A CONTRACTION represents the\r\n  first of the two-step _ARC RETRACTION PROTOCOL_ that effects the reclaimation\r\n  of allocated storage no longer used and the optimization of of lookup\r\n  efficiency by compacting CTRIE depth and thereby the number of levels\r\n  which must be traversed.  For further information, refer to the function\r\n  `CNODE-COMPRESSED` which implements the second stage of this protocol,\r\n  completing the process.\r\n\r\n\r\n_[function]_         `CNODE-COMPRESSED  (CNODE LEVEL)`\r\n\r\n> The _COMPRESSION_ of a CNODE is the second step of the _ARC\r\n  RETRACTION PROTOCOL_ completing a retraction that has been initiated\r\n  by `CNODE-CONTRACTED`.  The CNODE compression is computed by\r\n  generating a replacement cnode structure that is similar to CNODE,\r\n  but with any entombed inode arcs created during contraction simply\r\n  replaced by the SNODE that had been entombed. This is called the\r\n  _RESURRECTION_ of that SNODE. After all entombed inode arcs of a\r\n  cnode have been collapsed into simple SNODE leaves, if the resulting\r\n  CNODE has been compressed so far as to contain only a single SNODE\r\n  leaf, it is subjected to another CONTRACTION before it is returned\r\n  as the result of the compression. Otherwise it is simply returned\r\n  and represents a complete iteration of the _ARC RETRACTION PROTOCOL_\r\n\r\n\r\n_[function]_         `CLEAN  (INODE LEVEL)`\r\n\r\n> CLEAN is the basic entry-point into the arc retraction protocol. Given an\r\n  arbitrary, non-root inode referencing a CNODE that can be compressed,\r\n  update that inode to reference the result of that compression.  Otherwise\r\n  INODE will remain unaffected.\r\n\r\n\r\n_[function]_         `CLEAN-PARENT  (PARENT-INODE TARGET-INODE KEY LEVEL)`\r\n\r\n> During a `CTRIE-DROP` (`%remove`) operation, if the result of a KEY/VALUE\r\n  removal is an arc consisting of an `ENTOMBED` inode (one referencing a TNODE), then,\r\n  if that arc remains accessible from the parent of a CNODE containing it, generate\r\n  the compression of that CNODE and update its parent INODE with the result.\r\n\r\n\r\n_[structure]_        `RDCSS-DESCRIPTOR ()`\r\n\r\n> An RDCSS-DESCRIPTOR object represents a 'plan' for a proposed RDCSS\r\n  (restricted double compare single swap) operation. The use of this\r\n  descriptor object provides the means to effect an atomic RDCSS in\r\n  software, requiring only hardware support for single-word CAS, which is\r\n  preferable because it is commonly available on curent consumer hardware.\r\n   - `OV`        designates a slot containing the OLD (current) root inode.\r\n                 If the swap is unsuccessful, the resulting ctrie will revert\r\n                 to this structure as the root inode. \r\n   - `OVMAIN`    designates a slot containing the CNODE that is referenced\r\n                 by the OLD (current) root inode.\r\n   - `NV`        designates a slot containing a fully assembled replacement\r\n                 root inode referencing a valid CNODE. This pair will become\r\n                 the root inode and level 0 MAIN-NODE of the ctrie if the\r\n                 swap is successful.\r\n   - `COMMITTED` designates a flag which, when not NIL, indicates that the\r\n                 RDCSS plan defined by this descriptor has completed\r\n                 successfully\r\n\r\n\r\n_[function]_         `RDCSS-DESCRIPTOR-P  (OBJECT)`\r\n\r\n> Returns T if the specified object is of type rdcss-descriptor.\r\n\r\n\r\n_[function]_         `RDCSS-DESCRIPTOR-OV  (RDCSS-DESCRIPTOR)`\r\n\r\n> Returns the ov of the specified rdcss-descriptor\r\n\r\n\r\n\r\n_[function]_         `RDCSS-DESCRIPTOR-OVMAIN  (RDCSS-DESCRIPTOR)`\r\n\r\n> Returns the ovmain of the specified rdcss-descriptor\r\n\r\n\r\n\r\n_[function]_         `RDCSS-DESCRIPTOR-NV  (RDCSS-DESCRIPTOR)`\r\n\r\n> Returns the nv of the specified rdcss-descriptor\r\n\r\n\r\n\r\n_[function]_         `RDCSS-DESCRIPTOR-COMMITTED  (RDCSS-DESCRIPTOR)`\r\n\r\n> Returns and (with setf) changes the committed of the specified rdcss-descriptor\r\n\r\n\r\n\r\n_[function]_         `ROOT-NODE-ACCESS  (CTRIE &OPTIONAL ABORT)`\r\n\r\n> ROOT-NODE-ACCESS extends `FIND-CTRIE-ROOT`,\r\n  implementing the _RDCSS ROOT NODE PROTOCOL_ for access to root inode of\r\n  CTRIE.  In particular, it ensures that if, instead of an inode, the\r\n  root of CTRIE contains an RDCSS descriptor of a proposed root-node\r\n  update, that it will immediately invoke `ROOT-NODE-COMMIT` to act\r\n  on that descriptor and return an INODE struct that is the result of\r\n  the completed commit process. `ROOT-NODE-ACCESS` only provides access\r\n  to the root inode _STRUCTURE_ and in particular it does not provide\r\n  safe access to the _CONTENT_ of that inode. In order to access those\r\n  contents, the root inode returned by `ROOT-NODE-ACCESS` must be further\r\n  processed by `INODE-READ` in order to still properly comply with the\r\n  underlying GCAS protocol implementation requirements common to all\r\n  inodes\r\n\r\n\r\n_[function]_         `ROOT-NODE-REPLACE  (CTRIE OV OVMAIN NV)`\r\n\r\n> ROOT-NODE-REPLACE implements the _RDCSS ROOT NODE PROTOCOL_ for\r\n  replacement of the ROOT INODE of a CTRIE structure with another one\r\n  that contains new or alternative values, achieving the end-result\r\n  effectively the same as if by mutation.  The replacement of the root\r\n  inode is accomplished in two, basic conceptual stages. First, an\r\n  `RDCSS-DESCRIPTOR` object which specifies in full the current state\r\n  and all desired changes in the proposed resulting state.  Thus,\r\n  whether any individual replacement attempt succeeds or fails, either\r\n  result is guarenteed to represent a valid state. An attempt is then\r\n  made to atomically swap this RDCSS-DESCRIPTOR with the current CTRIE\r\n  root inode.  Note that, although it contains all of the information\r\n  representing two, distinct, root inode states, the RDCSS-DESCRIPTOR\r\n  is not, itself, a valid root inode.  That is the reason why all\r\n  access to the root inode must be accomplished using this specialized\r\n  _RDCSS ROOT NODE PROTOCOL_ rather than just the _GCAS INODE\r\n  PROTOCOL_ alone, as is done with all other non-root inodes.  Once an\r\n  atomic compare-and-swap of an RDCSS-DESCRIPTOR object with the root\r\n  inode completes successfully, `ROOT-NODE-COMMIT` is invoked which\r\n  will attempt to complete the second step of this protocol.  The\r\n  result of that commit will be one or the other of the two valid\r\n  states defined in the RDCSS-DESCRIPTOR object.  If another thread\r\n  concurrently attempts access to a root node holding an\r\n  RDCSS-DESCRIPTOR object rather than an INODE, it will invoke\r\n  `ROOT-NODE-COMMIT` itself, possibly prempting our own attempt, but\r\n  guaranteeing nonblocking access to a valid root node by any concurrent\r\n  thread\r\n\r\n\r\n_[function]_         `ROOT-NODE-COMMIT  (CTRIE &OPTIONAL ABORT)`\r\n\r\n> rdcss api to complete a root-node transaction\r\n\r\n\r\n_[function]_         `CTRIE-SNAPSHOT  (CTRIE &KEY READ-ONLY)`\r\n\r\n> Atomically create a clone of CTRIE that may be operated upon\r\n  independently without affecting or being affected by operations or\r\n  content of the original CTRIE.  If READ-ONLY is NIL (the default),\r\n  the new CTRIE will be a READABLE/WRITABLE 'fork' of CTRIE (see\r\n  `CTRIE-FORK`) otherwise, the clone will be READABLE only, which has\r\n  considerable performance benefits in some circumstances, as the arcs\r\n  will not require `REFRESH` and should be the preferred mode when\r\n  updates (writability) of the clone are not required\r\n\r\n\r\n_[function]_         `CTRIE-CLEAR  (CTRIE)`\r\n\r\n> Atomically clear all entries stored in CTRIE, returning it to a condition\r\n  which returns `T` when tested with predicate `CTRIE-EMPTY-P`\r\n\r\n\r\n_[function]_         `CTRIE-PUT  (CTRIE KEY VALUE)`\r\n\r\n> Insert a new entry into CTRIE mapping KEY to VALUE.  If an entry\r\n  with key equal to KEY aleady exists in CTRIE, according to the\r\n  equality predicate defined by `CTRIE-TEST` then the priorbmapping\r\n  will be replaced by VALUE. Returns `VALUE` representing the\r\n  mapping in the resulting CTRIE\r\n\r\n\r\n_[function]_         `%INSERT  (INODE KEY VALUE LEVEL PARENT STARTGEN)`\r\n\r\n>    -  The detailed specifics required to perform an insertion into a\r\n  CTRIE map are defined by and contained within the `%INSERT` function,\r\n  which is not part of the USER API and should never be invoked\r\n  directly.  The procedures required for interaction with `%INSERT` are\r\n  managed entirely by the upper layer entry-points and should be\r\n  entirely invisible to the developer using CL-CTRIE.  The alogorithm is\r\n  intricate and requires quite some effort to figure out based on the\r\n  papers and documentation. For that reason this attempt is made to\r\n  properly document the process -- not to encourage anyone to fiddle\r\n  with it...\r\n\r\n  > 1.  A given call to %insert carries with it no guarantee that it will\r\n  actually succeed.  Further, there is no guarantee it will do anything\r\n  at all -- including ever returning to the caller having invoked it.\r\n  This is because there are a number of circumstances that may possibly\r\n  interfere with insertion in a lock-free concurrent data-structure and\r\n  in order to minimize the cost incurred by aborted attempts and\r\n  restarts, there is no effort wasted on careful condition handling or\r\n  recovery.  Instead, as soon as it is recognised that a particular\r\n  attempt will not succeed, Control is thrown via non-local exit\r\n  unceremoneously the entire call stack and restarting each time from\r\n  the very beginning. There are quite a few places within the process\r\n  where you will find these nonlocal exits. Originally I had in mind to\r\n  incorporate some additional insrumentation to track and gather\r\n  statistics the log the specifics of all this, and there are a number\r\n  of extension points provided.  For more details refer to the\r\n  `MULTI-CATCH` and `CATCH-CASE` control structure documentation.\r\n\r\n  > 2.  %insert ALWAYS begins at an INODE.  This is not surprising, of\r\n  course, since the root of the tree (where all inserts begin) is an\r\n  INODE, and because INODES are the only nodes that provide\r\n  mutability. When we which to effect change to the CTRIE regardless of\r\n  where or what type, It may only be accomplished by mutating the parent\r\n  INODE immediately above it to reference content that must be freshly\r\n  regenerated each time changes are required.  Once it is established\r\n  that the %insert always begins at an inode, we can reason further\r\n  about the sequence of events that follow by considering some of the\r\n  node oriented invariants for CTRIEs specified variously in the\r\n  academic literature.  First, it has been clearly defined that an INODE\r\n  structure may only reference three kinds of structure that we\r\n  collectively refer to as MAIN-NODES.  These are the three potential\r\n  cases which we will consider next.\r\n\r\n  > 3.  Consider first the TNODE. If indeed we follow an INODE and\r\n  discover it directly leads us to a TNODE, or 'Tomb Node'. This tells\r\n  us, first, that we have arrived at a dead-end, second that we must\r\n  assist with the 'compression' of this arc by invoking the `CLEAN`\r\n  operation on the tombed INODE's parent.  Finally, there is nothing\r\n  further we can do so we THROW to :RESTART.\r\n\r\n  > 4.  If traverse the INODE and arrive at an LNODE, we are also at the\r\n  end of the ARC, but if it is due to hash collision then the algorithm\r\n  then indeed it may be correct.  In this case we attempt to 'insert'\r\n  ourself in te LNODE chain and then invoke INODE mutate to atomic\r\n  commit and then THROW to :RESTART\r\n\r\n  > 5.  As a simple instance of the general case, we may arrive at a CNODE\r\n  with vacant arc that represents the index specified by the bits of our\r\n  KEY's hash code that are active for this level within the ctrie.  When\r\n  this is the case, we construct a replacement CNODE augmented with our\r\n  key/value pair as an SNODE LEAF at the physical position within the\r\n  CNODES storage vector appropriately translated from the logical arc\r\n  index as described by the documentation of the functions\r\n  `FLAG-ARC-POSITION` and `FLAG-VECTOR` If we successfully mutate the\r\n  parent inode by completing an atomic replacement of the old cnode with\r\n  the one we constructed, then our insertion has succeeded and we return\r\n  the range value now successfully mapped by KEY in order to indicate\r\n  our success.  Otherwise we THROW to :RESTART.\r\n\r\n  > 6.  If we find the logical index of our 'arc' in this CNODE is not\r\n  empty and available as we did above, there are exactly two other\r\n  possibly find there; we know this because it is required to be a\r\n  BRANCH-NODE -- either an snode leaf storage or an inode referencing a\r\n  MAIN-NODE that represents the next layer of the CTRIE.  We describe\r\n  various posible cases and the define a procedure specified for each\r\n  below.\r\n\r\n  > 7.  If we find that the node PRESENT at this index is an INODE, then\r\n  this is the simplest of the possible cases.  Conceptually, what we\r\n  intend to do is continue to follow our arc, descending to the next\r\n  level of the CTRIE structure that is referenced by that inode.  In\r\n  practice, however, we are required to consider the possibility that\r\n  the generational descriptor object the inode contains may not be\r\n  consistent with STARTGEN, which is the one current in the root INODE\r\n  of this CTRIE.  This may be the case, for example, as the result of\r\n  some past cloning/snapshot operation if we are the first since then to\r\n  traverse this inode. (Remember that the refresh of generational\r\n  descriptor occurs lazily on an as-needed basis in order to avoid\r\n  overhead incurred by eager traversals which often turn out to have\r\n  been unnecessary).  In consideration of this we proceeed as follows: -\r\n  If the inode generational descriptor is consistent with STARTGEN, we\r\n  simply continue along our arc by recursively invoking `%insert` on\r\n  that INODE.  If that function call returns successfully with a VALUE,\r\n  then the insertion was successful, and we also then return, passing\r\n  along that value.  Thus the result is communicated back through the\r\n  caller chain, eventually arriving back as the result of the original\r\n  CTRIE-PUT entry-point.  - Otherwise if the generational descriptor is\r\n  not consistent with STARTGEN we attempt an atomic `INODE-MUTATE` on\r\n  the PARENT INODE of this CNODE that effects the replacement of that\r\n  inode within it by one FRESHLY CREATED by `REFRESH` and ensured to be\r\n  consistent with STARTGEN.  If this succeeds, we invoke %insert\r\n  recusively and proceed in the same manner, since, effectively, we are\r\n  now in a state equivalent to the one described above.  - If the\r\n  INODE-MUTATE of the prior step did NOT succeed, then we are out of\r\n  options and throw to :RESTART the insertion process from the beginning\r\n  all over again.\r\n\r\n  > 8.  If we find that the node PRESENT at this index is an SNODE,\r\n  then our situation becomes a little bit more complex and\r\n  there are a few more contingencies we must be prepared to\r\n  address.\r\n\r\n  > 9.  Once again, looking at the simplest first, when an insert\r\n  operation encounters a leaf-node somewhere along the descent of it's\r\n  'own' arc, one potential case is that it found the node it was\r\n  looking for -- one that contains a key that satisfies the test\r\n  predicate defined for the dynamic extent of the current operation,\r\n  `CTEQUAL,` when compared to the `KEY` currently being `%INSERTED.`\r\n  If the equality test is satisfied then the VALUE that node maps\r\n  should be updated with the one of the present insertion.  The steps\r\n  to effect the update are very similar to those of step 5, however We\r\n  construct a replacement CNODE augmented with our key/value pair as a\r\n  replacement SNODE in the SAME physical position as the one we have\r\n  found -- refer to the documentation for the function `CNODE-UPDATED`\r\n  for additional specifics on the internal details that describe this\r\n  operation.  If we successfully mutate the parent inode by completing\r\n  an atomic replacement of the old cnode with the one we constructed,\r\n  then our update has succeeded and we return the range value now\r\n  successfully mapped by KEY in order to indicate our success.\r\n  Otherwise we THROW to :RESTART.\r\n\r\n  > 10.  In some circumstances, we encounter a node on our arc whose\r\n  hash code bits have matched that of the current key of this\r\n  insertion for all of the lower order bits that have been consumed so\r\n  far, up to the current depth, but that (as opposed to step 9) does\r\n  not satisfy `CTEQUAL.` and so is NOT a candidiate for update\r\n  replacement.  Except in very vare circumstances, there will be some\r\n  depth at which the active bits of its hash code will indeed be\r\n  distinct from our own, and at that point a CNODE can be constructed\r\n  that will proprerly contain both it and an snode mapping the\r\n  key/value of the current insertion.  This means we must ENTEND the\r\n  ctrie as many layers as needed to get to that depth, inserting\r\n  CNODES and INODES at each step along the way.  Now, we will first\r\n  describe the 'edge' case where we have encounted the 'rare\r\n  circumstance.' If we perform this process and arrive at a depth\r\n  where all 32 hash code bits have been consumed and, indeed, these\r\n  two unequal keys are the result of a 'hash code collision' In order\r\n  that we preserve correct operation, we respond in this case by\r\n  chaining these key/value SNODES into a linked list of LNODES.\r\n  Therefore, they can share the same arc index and when we encounter\r\n  such a thing during future traversals, we can accomodate the\r\n  collision using simple linear search and a few basic LNODE utility\r\n  functions such as `LNODE-INSERTED` `LNODE-REMOVED` `LNODE-SEARCH`\r\n  `LNODE-LENGTH` and the list constructor `ENLIST.` Once we have\r\n  `ENLIST`ed the colliding SNODES, we create a new INODE pointing to\r\n  that list, and then attempt atomic replacement of the CNODE above\r\n  with one we extend to contain that INODE.  If we do successfully\r\n  mutate the prior CNODES parent INODE resulting in its replacement\r\n  with the CNODE we constructed, then our insert has succeeded and we\r\n  return the range value now successfully mapped by KEY in order to\r\n  indicate our success.  Otherwise we THROW to :RESTART.\r\n\r\n  > 11.  Finally, let us return to those intermediate steps, mentioned\r\n  above, to specify the means by which we perform the level-by-level\r\n  extension of a given arc to accommodate both the above case of hash\r\n  collision as well as the more common one when the reason for\r\n  extension is simply to accomodate normal growth capacity and\r\n  allocation.  In both cases, though, the extensions are performed for\r\n  the same initiating cause -- to accomodate the collision of leaf\r\n  node keys resident at lower levels of the structure.  Depending on\r\n  the similarity of two colliding hash keys, the extension process may\r\n  not be resolved with a single iteration.  In the case of full\r\n  collisiion, described above, the extension process will recur, up to\r\n  a maximum depth of `(32/W)` levels, at which point an L-NODE chain\r\n  will be created.  At each iteration, a new INODE is created,\r\n  pointing to a new CNODE containing one of our conflictung pairs.\r\n  Then, `%INSERT` is attempted on that INODE and this process recurs.\r\n  Once this cycle of insert/extend completes, each INODE/CNODE pair is\r\n  returned to the parent -- the entire newly created structure\r\n  eventually returning to the point of original conflicts whre the\r\n  extension cycle began.  If we successfully mutate the parent inode\r\n  by completing an atomic replacement of the old cnode with the one\r\n  that begins this newly built structue, then our update has succeeded\r\n  and we return the range value now successfully mapped by KEY in\r\n  order to indicate our success.  Otherwise we THROW to :RESTART\r\n\r\n\r\n_[function]_         `CTRIE-GET  (CTRIE KEY)`\r\n\r\n> Find the entry in CTRIE whose key is KEY and returns the\r\n  associated value and T as multiple values, or returns NIL and NIL\r\n  if there is no such entry. Entries can be added using SETF.\r\n\r\n\r\n_[function]_         `%LOOKUP  (INODE KEY LEVEL PARENT STARTGEN)`\r\n\r\n> The general concept of the procedure for finding a given key within\r\n  a simplified SEQUENTIAL model of a CTRIE can be summarized as\r\n  follows: If the internal node is at level `L` then the W bits of the\r\n  hashcode starting from position `W * L` are used as a logical index\r\n  into the vector of `2^W` arcs that can possibly be represented\r\n  within that node (see `FLAG` and `FLAG-VECTOR`). This logical index\r\n  is then transformed into a physical index that denotes a specific\r\n  position locating this arc relative to all other arcs currently\r\n  present in the node (see `FLAG-ARC-POSITION`.  In this way, storage\r\n  within the node need not be allocated for representation of empty\r\n  arc positions. At all times the invariant is maintained that the\r\n  number of arcs allocated within a given CNODE is equal to the\r\n  Hamming-Weight of its BITMAP -- i.e., the number of nonzero bits\r\n  present (see `CL:LOGCOUNT`). The arc at this calculated relative\r\n  position is then followed, and the process repeated until arrival at\r\n  a leaf-node or empty arc position.  Locating a given key becomes\r\n  substantially more complicated in the actual lock-free concurrent\r\n  ctrie algorithm\r\n\r\n\r\n_[function]_         `CTRIE-DROP  (CTRIE KEY)`\r\n\r\n> Remove KEY and it's associated value from CTRIE. Returns as multiple\r\n  values the value associated with KEY and T if there was such an entry,\r\n  otherewise NIL and NIL\r\n\r\n\r\n_[function]_         `%REMOVE  (INODE KEY LEVEL PARENT STARTGEN)`\r\n\r\n_[function]_         `CTRIE-MAP  (CTRIE FN &KEY ATOMIC &AUX ACCUM)`\r\n\r\n> Applies a function two arguments, FN, to each (key . value) pair present in\r\n  CTRIE.  During the extent of CTRIE-MAP, a special variable ACCUM (initially NIL)\r\n  is available for accumulation of a result value which will be returned after\r\n  the completion of the CTRIE-MAP call.  If ATOMIC is non-NIL, the operation will\r\n  be performed on a read-only atomic snapshot of CTRIE, which guarantees a\r\n  consistent, point-in-time representation of the entries present in CTRIE\r\n\r\n\r\n_[macro]_            `CTRIE-DO  ((KEY VALUE CTRIE &KEY ATOMIC) &BODY BODY)`\r\n\r\n> Iterate over the contents of CTRIE in the manner of dolist. For each\r\n  (key . value) pair present in CTRIE, BODY (implicit PROGN) will be\r\n  evaluated with the symbols specified for KEY and VALUE will be bound\r\n  to the respective entry constituents.  A special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the CTRIE-DO\r\n  call.  If ATOMIC is non-NIL, the operation will be performed on a\r\n  read-only atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries present in CTRIE.\r\n  ```\r\n  ;;;  EXAMPLE: (ctrie-do (k v ctrie)\r\n  ;;;             (format t \"~&~8S => ~10S~%\" k v))\r\n  ```\r\n\r\n\r\n_[function]_         `CTRIE-MAP-KEYS  (CTRIE FN &KEY ATOMIC)`\r\n\r\n> Applies a function one argument, FN, to each key present in CTRIE.\r\n  During the extent of CTRIE-MAP-KEYS, a special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the\r\n  CTRIE-MAP-KEYS call.  If ATOMIC is non-NIL, the operation will be\r\n  performed on a read-only atomic snapshot of CTRIE, which guarantees\r\n  a consistent, point-in-time representation of the keys present in\r\n  CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-MAP-VALUES  (CTRIE FN &KEY ATOMIC)`\r\n\r\n> Applies a function one argument, FN, to each value present in CTRIE.\r\n  During the extent of CTRIE-MAP-VALUES, a special variable\r\n  ACCUM (initially NIL) is available for accumulation of a result\r\n  value which will be returned after the completion of the\r\n  CTRIE-MAP-VALUES call.  If ATOMIC is non-NIL, the operation will be\r\n  performed on a read-only atomic snapshot of CTRIE, which guarantees\r\n  a consistent, point-in-time representation of the values present in\r\n  CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-KEYS  (CTRIE &KEY ATOMIC)`\r\n\r\n> Construct and return a list containing all keys present in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the keys present in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-VALUES  (CTRIE &KEY ATOMIC)`\r\n\r\n> Construct and return a list containing all values present in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the values present in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-SIZE  (CTRIE &KEY ATOMIC &AUX (ACCUM 0))`\r\n\r\n> Return the number of entries present in CTRIE.  If ATOMIC is non-NIL,\r\n  the operation will be performed on a read-only atomic snapshot of CTRIE,\r\n  which guarantees a consistent, point-in-time representation of CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-EMPTY-P  (CTRIE)`\r\n\r\n> Return T if CTRIE contains no entries, otherwise NIL. This function is\r\n  O(1) and is much more efficient than testing for `CTRIE-SIZE` of 0\r\n\r\n\r\n_[function]_         `CTRIE-TO-ALIST  (CTRIE &KEY ATOMIC)`\r\n\r\n> Return an alist containing all (key . value) pairs found in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries in CTRIE\r\n\r\n\r\n_[function]_         `CTRIE-TO-HASHTABLE  (CTRIE &KEY ATOMIC HASH-TABLE &AUX\r\n                                           (ACCUM\r\n                                            (OR HASH-TABLE\r\n                                                (MAKE-HASH-TABLE :TEST\r\n                                                                 (CTRIE-TEST\r\n                                                                  CTRIE)\r\n                                                                 :HASH-FUNCTION\r\n                                                                 (CTRIE-HASH\r\n                                                                  CTRIE)\r\n                                                                 :SYNCHRONIZED\r\n                                                                 ATOMIC))))`\r\n\r\n> Return a hash-table containing all (key . value) pairs found in CTRIE.\r\n  If ATOMIC is non-NIL, the operation will be performed on a read-only\r\n  atomic snapshot of CTRIE, which guarantees a consistent,\r\n  point-in-time representation of the entries in CTRIE. If HASH-TABLE\r\n  is specified, it will be used as the destination hash-table.\r\n  Otherwise, a new hash-table will be created with hash-function and\r\n  test identical to that of CTRIE.  It will be created as synchronized\r\n  if ATOMIC is not NIL\r\n\r\n\r\n_[function]_         `CTRIE-PPRINT  (CTRIE &OPTIONAL (STREAM T))`\r\n\r\n> Pretty-print a representation of CTRIE as an alist containing\r\n  all (key . value) pairs found in it.  Atomicity is not guaranteed\r\n\r\n\r\n_[function]_         `CTRIE-FROM-ALIST  (ALIST &KEY CTRIE)`\r\n\r\n> Return a CTRIE containing all (key . value) pairs found in ALIST.\r\n  If CTRIE is specified, it will be used as the destination ctrie.\r\n  Otherwise, a new ctrie will be created. Atomicity is not guaranteed\r\n\r\n\r\n_[function]_         `CTRIE-FROM-HASHTABLE  (HASH-TABLE &KEY CTRIE)`\r\n\r\n> Return a CTRIE containing all (key . value) pairs found in HASH-TABLE.\r\n  If CTRIE is specified, it will be used as the destination ctrie.\r\n  Otherwise, a new ctrie will be created with test identical to that\r\n  of HASH-TABLE. The hash-function will NOT be preserved, as that\r\n  information does not appear to be recoverable from a hash-table once\r\n  created\r\n\r\n\r\n_[function]_         `CTRIE-MAX-DEPTH  (THING)`\r\n\r\n> Compute the maximum length of any arc. Useful as a diagnostic\r\n\r\n\r\n_[function]_         `CTRIE-MIN-DEPTH  (THING)`\r\n\r\n> Compute the minimum length of any arc. Useful as a diagnostic\r\n\r\n\r\n_[function]_         `CTRIE-SNAPSHOT  (CTRIE &KEY READ-ONLY)`\r\n\r\n> Atomically create a clone of CTRIE that may be operated upon\r\n  independently without affecting or being affected by operations or\r\n  content of the original CTRIE.  If READ-ONLY is NIL (the default),\r\n  the new CTRIE will be a READABLE/WRITABLE 'fork' of CTRIE (see\r\n  `CTRIE-FORK`) otherwise, the clone will be READABLE only, which has\r\n  considerable performance benefits in some circumstances, as the arcs\r\n  will not require `REFRESH` and should be the preferred mode when\r\n  updates (writability) of the clone are not required\r\n\r\n\r\n_[function]_         `CTRIE-FORK  (CTRIE)`\r\n\r\n> Atomically create a READABLE and WRITABLE clone of CTRIE that may\r\n  be operated upon independently without affecting or being affected\r\n  by the original CTRIE.\r\n\r\n\r\n_[macro]_            `CTRIE-LAMBDA  (&ONCE CTRIE &REST REST)`\r\n\r\n> Pandoric Object and Inter-Lexical Communication Protocol\r\n  this macro builds the most unencumbered and widely applicable\r\n  'purist edition' Of our PLAMBDA based form.  Even as such,\r\n  a lot of care has been given to many subtle ways it has been\r\n  refined to offer the most convenient and natural tool possible.\r\n  ```;;;\r\n     ;;; (plambda (#<CLOSURE (LAMBDA (&REST ARGS)) {100929EB1B}> )\r\n     ;;;\r\n     ;;; DISPATCHING to FUNCTIONAL MAPPING:\r\n     ;;;   (IF (REST ARGS)\r\n     ;;;          (APPLY ARG (REST ARGS))\r\n     ;;;          (FUNCALL ARG #'IDENTITY)) =>\r\n     ;;; ------------------------------------------------------------\r\n     ;;; INITIALIZING PLAMBDA\r\n     ;;; ------------------------------------------------------------\r\n     ;;;   IT => #S(CTRIE\r\n     ;;;               :READONLY-P NIL\r\n     ;;;               :TEST EQUAL\r\n     ;;;               :HASH SXHASH\r\n     ;;;               :STAMP #<CLOSURE (LAMBDA # :IN CONSTANTLY) {10092B516B}>\r\n     ;;;               :ROOT #S(INODE\r\n     ;;;                        :GEN #:|ctrie2196|\r\n     ;;;                        :REF #S(REF\r\n     ;;;                                :STAMP @2012-08-19T13:34:58.314457-04:00\r\n     ;;;                                :VALUE #S(CNODE :BITMAP 0 :ARCS #())\r\n     ;;;                                :PREV NIL)))\r\n     ;;;   PLIST => (:CONTAINER #<CLOSURE (LAMBDA #) {100929EACB}> \r\n     ;;;             :TIMESTAMP @2012-08-19T13:34:58.314464-04:00)\r\n     ;;;   STACK => (#<CLOSURE (LAMBDA #) {100929EACB}>)\r\n     ;;; \r\n     ;;; ------------------------------------------------------------\r\n     ;;;  #<CLOSURE (LAMBDA (&REST #:ARGS55)) {100929EACB}>\r\n     ;;;```\r\n\r\n\r\n_[generic-function]_ `CTRIE-LAMBDA-CTRIE  (CTRIE-LAMBDA-OBJECT)`\r\n\r\n> Returns and (with setf) changes the ctrie of the specified ctrie-lambda-object\r\n\r\n\r\n\r\n_[function]_         `CTRIE-LAMBDA-SPAWN  (SELF &KEY READ-ONLY)`\r\n\r\n> Causes the atomic clone of enclosed ctrie structure and builds a new\r\n  lexical closure to operate on it.  Does not bother to reproduce fancy\r\n  (expensive) object, class, bindings, but provides almost identical\r\n  functionality.  May be used to more efficintly distribute workload\r\n  in parallel\r\n\r\n\r\n_[macro]_            `DEFINE-CTRIE  (NAME CTRIE &REST ARGS &KEY (OBJECT T) SPEC)`\r\n\r\n> Define a 'functional' __CTRIE-LAMBDA__ that combines all the the\r\n  capabilities of the raw data structure with behavior and semantics\r\n  one would expect of any other ordinary common-lisp function.  The\r\n  resulting symbol defined as 'name will be bound in three distinct\r\n  namespaces: the `SYMBOL-VALUE` will be bound to the LAMBDA CLOSURE\r\n  object, `SYMBOL-FUNCTION` (fdefinition) will be FBOUND to the\r\n  compiled function, and the corresponding '(SETF NAME) form will be\r\n  SETF-BOUND.  the syntax for invoking NAME is as in a LISP1; i.e., no\r\n  'funcall' is required (but still works if you prefer).\r\n  Calling `(NAME key)` returns the value mapped to key, or `NIL` just\r\n  as if by `(CTRIE-GET ctrie-name key).` Analogously when used as a\r\n  setf-able place such as by `(setf (NAME key) value)` it has the\r\n  equivalent behavior to the operation `(CTRIE-PUT ctrie-name key\r\n  value).` Use of this type of binding technique has some really\r\n  convenient effects that I've quickly started to become quite fond\r\n  of.  One such idiom, for example, `(mapcar MY-CTRIE '(key1 key2 key3\r\n  key4 ...))` returns a list containing all the mapped values\r\n  corresponding to the respective keys.  One additional feature that\r\n  I've found extremely useful is included _under the hood:_ Invoking\r\n  MY-CTRIE on an object of type FUNCTION will not search the ctrie for\r\n  an entry having that function ast its key, but will instead APPLY\r\n  that function to the actual CTRIE structure wrapped within the\r\n  closure.  Thus, `(MY-CTRIE #'identity)` will return the underlying\r\n  ctrie as just an ordinary instance of a CTRIE STRUCTURE.  \r\n  There are many other functions this is handy with, like\r\n  `(MY-CTRIE #'ctrie-size)` `(MY-CTRIE #'ctrie-to-hashtable)`\r\n  etc.  Some additional examples are provided below.\r\n  ```\r\n  ;;;  (define-ctrie my-ctrie)\r\n  ;;;    =>  MY-CTRIE\r\n  ;;;\r\n  ;;;  (describe 'my-ctrie)\r\n  ;;;\r\n  ;;;     CL-CTRIE::MY-CTRIE\r\n  ;;;       [symbol]\r\n  ;;;    \r\n  ;;;     MY-CTRIE names a special variable:\r\n  ;;;       Value: #<CLOSURE (LAMBDA # :IN MAKE-CTRIE-LAMBDA) {100F73261B}>\r\n  ;;;    \r\n  ;;;     MY-CTRIE names a compiled function:\r\n  ;;;       Lambda-list: (&REST ARGS1)\r\n  ;;;       Derived type: FUNCTION\r\n  ;;;    \r\n  ;;;     (SETF MY-CTRIE) names a compiled function:\r\n  ;;;       Lambda-list: (VALUE KEY)\r\n  ;;;       Derived type: (FUNCTION (T T) *)\r\n  ;;;\r\n  ;;;\r\n  ;;;   (my-ctrie :HONG-KONG :FOOY)\r\n  ;;;     =>  :FOOY\r\n  ;;;\r\n  ;;;   (my-ctrie :HONG-KONG)\r\n  ;;;     =>  :FOOY ; T\r\n  ;;;\r\n  ;;;   (map 'list #'eval (mapcar #`(my-ctrie ,a1 ,a1) (iota 12)))\r\n  ;;;     =>  (0 1 2 3 4 5 6 7 8 9 10 11)\r\n  ;;;\r\n  ;;;   (mapcar my-ctrie (iota 12))\r\n  ;;;     =>  (0 1 2 3 4 5 6 7 8 9 10 11)\r\n  ```\r\n\r\n\r\n_[macro]_            `CTRIE-ERROR  (CONDITION &REST ARGS)`\r\n\r\n> Signal a CTRIE related condition.\r\n\r\n\r\n_[condition]_        `CTRIE-ERROR (ERROR)`\r\n\r\n> Abstract superclass of CTRIE related conditions.\r\n\r\n\r\n_[condition]_        `CTRIE-STRUCTURAL-ERROR (CTRIE-ERROR)`\r\n\r\n> Condition designating that the CTRIE data structure\r\n   has been determined to be invalid.\r\n\r\n\r\n_[condition]_        `CTRIE-OPERATIONAL-ERROR (CTRIE-ERROR)`\r\n\r\n> Condition for when an operational failure or\r\n  inconsistency has occurred.\r\n\r\n\r\n_[function]_         `CTRIE-MODIFICATION-FAILED  (REASON &KEY OP PLACE)`\r\n\r\n> Signal a modification failure with the appropriate attendant metadata.\r\n\r\n\r\n_[condition]_        `CTRIE-MODIFICATION-FAILED (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> This condition indicates an unhandled failure of an attempt to\r\n         perform stateful modification to CTRIE.  The most common case in\r\n         which this might occur is when such an attempt is mode on a CTRIE\r\n         designated as READONLY-P.  In any case, this condition represents an\r\n         exception from which processing cannot continue and requires\r\n         interactive user intervention in order to recover.\r\n\r\n\r\n_[condition]_        `CTRIE-OPERATION-RETRIES-EXCEEDED (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> Condition indicating an operation has failed the\r\n   maximum number of times specified by the special-variable\r\n   *retries*\r\n\r\n\r\n_[condition]_        `CTRIE-NOT-IMPLEMENTED (CTRIE-ERROR)`\r\n\r\n> Condition designating functionality for which the\r\n   implementation has not been written, but has not been deliberately\r\n   excluded.\r\n\r\n\r\n_[condition]_        `CTRIE-NOT-SUPPORTED (CTRIE-ERROR)`\r\n\r\n> Condition designating functionality that is\r\n  deliberately not supported.\r\n\r\n\r\n_[condition]_        `CTRIE-INVALID-DYNAMIC-CONTEXT (CTRIE-OPERATIONAL-ERROR)`\r\n\r\n> Condition indicating an operation was attempted\r\n   outside the dynamic extent of a valid enclosing WITH-CTRIE form\r\n\r\n\r\n_[condition]_        `CTRIE-GENERATIONAL-MISMATCH (CTRIE-STRUCTURAL-ERROR)`\r\n\r\n> Condition indicating an operation encountered an\r\n   outdated or inconsistent node during its attempted traversal\r\n\r\n\r\n_[function]_         `README  (&OPTIONAL (STREAM *STANDARD-OUTPUT*))`\r\n\r\n> Update documentation sections of the README file. When an output stream\r\n  is specified, the results are also echoed to that stream. To inhibit\r\n  output, invoke as `(readme (make-broadcast-stream))` or use `README-QUIETLY`\r\n\r\n\r\n_[function]_         `README-QUIETLY  ()`\r\n\r\n> Update documentation sections of the README file, inhibiting any other\r\n  printed output.\r\n\r\n\r\n_[function]_         `APIDOC  (&OPTIONAL (SCOPE :EXTERNAL))`\r\n\r\n> Collect a list of strings representing the documentation for\r\n  CL-CTRIE rendered in a compact format suitable for inclusion in a\r\n  lightweight text-markup format document.  If SCOPE is specified it\r\n  must be either :EXTERNAL. corresponding to those symbols exported as\r\n  the public API, or :HOME, which designates all symbols defined\r\n  locally in package.\r\n\r\n\r\n_[function]_         `PRINC-APIDOC  (&OPTIONAL (SCOPE :EXTERNAL))`\r\n\r\n> Print to `*STANDARD-OUTPUT*` the documentation for CL-CTRIE rendered\r\n  in a compact format.  This is intended primarily as a convenience to\r\n  the interactive user seeking quick reference at the REPL.  If SCOPE\r\n  is specified it must be either :EXTERNAL. corresponding to those\r\n  symbols exported as the public API, or :HOME, which designates all\r\n  symbols defined locally in package.\r\n\r\n\r\n_[function]_         `COLLECT-DOCS  (&OPTIONAL (SCOPE :EXTERNAL)\r\n                                     (SORT #'STRING<))`\r\n\r\n> Regenerate on-disk html documentation and collect the cached\r\n  in-memory descriptors for further processing. If SCOPE is specified\r\n  it must be either :EXTERNAL. corresponding to those symbols exported\r\n  as the public API, or :HOME, which designates all symbols defined\r\n  locally in package.  Output order may be customized by an optionally\r\n  specified SORT function.\r\n\r\n\r\n_[macro]_            `DEFINE-DIAGRAM  (TYPE (&OPTIONAL CONTEXT) &BODY BODY)`\r\n\r\n> Define a diagrammatic representation of TYPE, optionally specialized\r\n  for a specific CONTEXT. See {defgeneric cl-ctrie::make-diagram}.\r\n\r\n\r\n* * * * * * *\r\n","google":"UA-37992128-3","note":"Don't delete this file! It's used internally to help with page regeneration."}